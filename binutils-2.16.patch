--- binutils-2.16.orig/bfd/Makefile.am	2005-05-02 12:45:42.000000000 -0700
+++ binutils-psp/bfd/Makefile.am	2005-07-22 22:17:36.000000000 -0700
@@ -3,7 +3,7 @@
 AUTOMAKE_OPTIONS = 1.9 cygnus
 
 # Uncomment the following line when doing a release.
-RELEASE=y
+#RELEASE=y
 
 INCDIR = $(srcdir)/../include
 CSEARCH = -I. -I$(srcdir) -I$(INCDIR)
--- binutils-2.16.orig/bfd/bfd-in2.h	2005-03-02 13:23:20.000000000 -0800
+++ binutils-psp/bfd/bfd-in2.h	2005-06-19 18:09:32.000000000 -0700
@@ -1600,6 +1600,7 @@
 #define bfd_mach_mips16                16
 #define bfd_mach_mips5                 5
 #define bfd_mach_mips_sb1              12310201 /* octal 'SB', 01 */
+#define bfd_mach_mips_allegrex         10111431 /* octal 'AL', 31 */
 #define bfd_mach_mipsisa32             32
 #define bfd_mach_mipsisa32r2           33
 #define bfd_mach_mipsisa64             64
--- binutils-2.16.orig/bfd/archures.c	2005-01-17 06:08:03.000000000 -0800
+++ binutils-psp/bfd/archures.c	2005-06-19 18:09:32.000000000 -0700
@@ -155,6 +155,7 @@
 .#define bfd_mach_mips16		16
 .#define bfd_mach_mips5                 5
 .#define bfd_mach_mips_sb1              12310201 {* octal 'SB', 01 *}
+.#define bfd_mach_mips_allegrex         10111431 {* octal 'AL', 31 *}
 .#define bfd_mach_mipsisa32             32
 .#define bfd_mach_mipsisa32r2           33
 .#define bfd_mach_mipsisa64             64
--- binutils-2.16.orig/bfd/elfxx-mips.c	2005-04-19 11:37:04.000000000 -0700
+++ binutils-psp/bfd/elfxx-mips.c	2005-06-19 18:09:32.000000000 -0700
@@ -4669,6 +4669,9 @@
     case E_MIPS_MACH_SB1:
       return bfd_mach_mips_sb1;
 
+    case E_MIPS_MACH_ALLEGREX:
+      return bfd_mach_mips_allegrex;
+
     default:
       switch (flags & EF_MIPS_ARCH)
 	{
@@ -7882,6 +7885,10 @@
       val = E_MIPS_ARCH_64 | E_MIPS_MACH_SB1;
       break;
 
+    case bfd_mach_mips_allegrex:
+      val = E_MIPS_ARCH_2 | E_MIPS_MACH_ALLEGREX;
+      break;
+
     case bfd_mach_mipsisa32:
       val = E_MIPS_ARCH_32;
       break;
@@ -9582,6 +9589,7 @@
   /* MIPS II extensions.  */
   { bfd_mach_mips4000, bfd_mach_mips6000 },
   { bfd_mach_mipsisa32, bfd_mach_mips6000 },
+  { bfd_mach_mips_allegrex, bfd_mach_mips6000 },
 
   /* MIPS I extensions.  */
   { bfd_mach_mips6000, bfd_mach_mips3000 },
--- binutils-2.16.orig/bfd/cpu-mips.c	2005-03-03 03:40:58.000000000 -0800
+++ binutils-psp/bfd/cpu-mips.c	2005-06-19 18:09:32.000000000 -0700
@@ -86,6 +86,7 @@
   I_mipsisa64,
   I_mipsisa64r2,
   I_sb1,
+  I_allegrex,
 };
 
 #define NN(index) (&arch_info_struct[(index) + 1])
@@ -118,7 +119,8 @@
   N (32, 32, bfd_mach_mipsisa32r2,"mips:isa32r2", FALSE, NN(I_mipsisa32r2)),
   N (64, 64, bfd_mach_mipsisa64,  "mips:isa64",   FALSE, NN(I_mipsisa64)),
   N (64, 64, bfd_mach_mipsisa64r2,"mips:isa64r2", FALSE, NN(I_mipsisa64r2)),
-  N (64, 64, bfd_mach_mips_sb1, "mips:sb1",       FALSE, 0),
+  N (64, 64, bfd_mach_mips_sb1, "mips:sb1",       FALSE, NN(I_sb1)),
+  N (32, 32, bfd_mach_mips_allegrex, "mips:allegrex", FALSE, 0),
 };
 
 /* The default architecture is mips:3000, but with a machine number of
--- binutils-2.16.orig/bfd/Makefile.in	2005-05-02 12:45:46.000000000 -0700
+++ binutils-psp/bfd/Makefile.in	2005-07-22 22:17:46.000000000 -0700
@@ -250,7 +250,7 @@
 AUTOMAKE_OPTIONS = 1.9 cygnus
 
 # Uncomment the following line when doing a release.
-RELEASE=y
+#RELEASE=y
 INCDIR = $(srcdir)/../include
 CSEARCH = -I. -I$(srcdir) -I$(INCDIR)
 MKDEP = gcc -MM
--- binutils-2.16.orig/bfd/version.h	2005-05-02 12:43:09.000000000 -0700
+++ binutils-psp/bfd/version.h	2005-08-22 09:29:10.064026312 -0700
@@ -1,3 +1,3 @@
-#define BFD_VERSION_DATE 20050502
+#define BFD_VERSION_DATE (PSPDEV 20050822)
 #define BFD_VERSION @bfd_version@
 #define BFD_VERSION_STRING @bfd_version_string@
--- binutils-2.16.orig/binutils/readelf.c	2005-04-20 11:43:36.000000000 -0700
+++ binutils-psp/binutils/readelf.c	2005-06-19 18:09:27.000000000 -0700
@@ -2043,6 +2043,7 @@
 	    case E_MIPS_MACH_5500: strcat (buf, ", 5500"); break;
 	    case E_MIPS_MACH_SB1:  strcat (buf, ", sb1");  break;
 	    case E_MIPS_MACH_9000: strcat (buf, ", 9000"); break;
+	    case E_MIPS_MACH_ALLEGREX: strcat (buf, ", allegrex"); break;
 	    case 0:
 	    /* We simply ignore the field in this case to avoid confusion:
 	       MIPS ELF does not specify EF_MIPS_MACH, it is a GNU
--- binutils-2.16.orig/config.sub	2005-01-18 16:34:56.000000000 -0800
+++ binutils-psp/config.sub	2005-06-24 17:01:46.000000000 -0700
@@ -253,6 +253,7 @@
 	| mipsisa64sb1 | mipsisa64sb1el \
 	| mipsisa64sr71k | mipsisa64sr71kel \
 	| mipstx39 | mipstx39el \
+	| mipsallegrex | mipsallegrexel \
 	| mn10200 | mn10300 \
 	| msp430 \
 	| ns16k | ns32k \
@@ -326,6 +327,7 @@
 	| mipsisa64sb1-* | mipsisa64sb1el-* \
 	| mipsisa64sr71k-* | mipsisa64sr71kel-* \
 	| mipstx39-* | mipstx39el-* \
+	| mipsallegrex-* | mipsallegrexel-* \
 	| mmix-* \
 	| msp430-* \
 	| none-* | np1-* | ns16k-* | ns32k-* \
@@ -665,6 +667,10 @@
 		basic_machine=m68k-atari
 		os=-mint
 		;;
+	psp)
+		basic_machine=mipsallegrexel-psp
+		os=-elf
+		;;
 	mips3*-*)
 		basic_machine=`echo $basic_machine | sed -e 's/mips3/mips64/'`
 		;;
--- binutils-2.16.orig/gas/config/tc-mips.c	2005-04-20 11:41:36.000000000 -0700
+++ binutils-psp/gas/config/tc-mips.c	2005-06-19 18:09:30.000000000 -0700
@@ -365,11 +365,15 @@
 #define CPU_HAS_MDMX(cpu)	(FALSE                 \
 				 )
 
+/* True if the given CPU belongs to the Allegrex family.  */
+#define CPU_IS_ALLEGREX(CPU)	((CPU) == CPU_ALLEGREX	\
+    				 )
+
 /* True if CPU has a dror instruction.  */
 #define CPU_HAS_DROR(CPU)	((CPU) == CPU_VR5400 || (CPU) == CPU_VR5500)
 
 /* True if CPU has a ror instruction.  */
-#define CPU_HAS_ROR(CPU)	CPU_HAS_DROR (CPU)
+#define CPU_HAS_ROR(CPU)	CPU_HAS_DROR (CPU) || CPU_IS_ALLEGREX (CPU)
 
 /* True if mflo and mfhi can be immediately followed by instructions
    which write to the HI and LO registers.
@@ -7817,6 +7821,30 @@
       case '%': USE_BITS (OP_MASK_VECALIGN,	OP_SH_VECALIGN); break;
       case '[': break;
       case ']': break;
+      case '?':
+	/* MRB TODO: Fix this for the VFPU extensions. */
+	switch (c = *p++)
+	  {
+	  case 'f':
+	    /* MRB HACK: Skip the next character. */
+	    p++;
+	    break;
+	  case 'd':
+	  case 'm':
+	  case 'n':
+	  case 's':
+	  case 't':
+	  case 'v':
+	  case 'x':
+	    /* MRB HACK: Skip the next two characters. */
+	    p++;
+	    p++;
+	    break;
+	  default: break;
+	  }
+	/* MRB HACK: Set all used bits. */
+	used_bits = 0xffffffff;
+	break;
       default:
 	as_bad (_("internal: bad mips opcode (unknown operand type `%c'): %s %s"),
 		c, opc->name, opc->args);
@@ -8485,6 +8513,7 @@
 
 		  if ((regno & 1) != 0
 		      && HAVE_32BIT_FPRS
+		      && ! CPU_IS_ALLEGREX (mips_opts.arch)
 		      && ! (strcmp (str, "mtc1") == 0
 			    || strcmp (str, "mfc1") == 0
 			    || strcmp (str, "lwc1") == 0
@@ -13743,6 +13772,8 @@
 
   /* MIPS II */
   { "r6000",          0,      ISA_MIPS2,      CPU_R6000 },
+  /* Sony PSP "Allegrex" CPU core */
+  { "allegrex",       0,      ISA_MIPS2,      CPU_ALLEGREX },
 
   /* MIPS III */
   { "r4000",          0,      ISA_MIPS3,      CPU_R4000 },
--- binutils-2.16.orig/gas/configure	2005-02-28 16:43:51.000000000 -0800
+++ binutils-psp/gas/configure	2005-06-19 18:09:30.000000000 -0700
@@ -4537,6 +4537,9 @@
 	  mips64vr | mips64vrel)
 	    mips_cpu=vr4100
 	    ;;
+	  mipsallegrex | mipsallegrexel)
+	    mips_cpu=allegrex
+	    ;;
 	  mipsisa32r2* | mipsisa64r2*)
 	    mips_cpu=`echo $target_cpu | sed -e 's/[a-z]*..r2//' -e 's/el$//'`
 	    ;;
--- binutils-2.16.orig/gas/configure.in	2005-02-28 16:43:57.000000000 -0800
+++ binutils-psp/gas/configure.in	2005-06-19 18:09:30.000000000 -0700
@@ -222,6 +222,9 @@
 	  mips64vr | mips64vrel)
 	    mips_cpu=vr4100
 	    ;;
+	  mipsallegrex | mipsallegrexel)
+	    mips_cpu=allegrex
+	    ;;
 	  mipsisa32r2* | mipsisa64r2*)
 changequote(,)dnl
 	    mips_cpu=`echo $target_cpu | sed -e 's/[a-z]*..r2//' -e 's/el$//'`
--- binutils-2.16.orig/include/elf/common.h	2004-10-08 06:55:08.000000000 -0700
+++ binutils-psp/include/elf/common.h	2005-06-19 18:09:25.000000000 -0700
@@ -93,6 +93,7 @@
 #define ET_HIOS		0xFEFF	/* Operating system-specific */
 #define ET_LOPROC	0xFF00	/* Processor-specific */
 #define ET_HIPROC	0xFFFF	/* Processor-specific */
+#define ET_PSPEXEC	0xFFA0	/* Sony PSP executable file */
 
 /* Values for e_machine, which identifies the architecture.  These numbers
    are officially assigned by registry@caldera.com.  See below for a list of
--- binutils-2.16.orig/include/elf/mips.h	2005-03-03 03:58:06.000000000 -0800
+++ binutils-psp/include/elf/mips.h	2005-06-19 18:09:25.000000000 -0700
@@ -212,6 +212,7 @@
 #define E_MIPS_MACH_5400	0x00910000
 #define E_MIPS_MACH_5500	0x00980000
 #define E_MIPS_MACH_9000	0x00990000
+#define E_MIPS_MACH_ALLEGREX	0x00A20000
 
 /* Processor specific section indices.  These sections do not actually
    exist.  Symbols with a st_shndx field corresponding to one of these
--- binutils-2.16.orig/include/opcode/mips.h	2005-03-03 03:58:10.000000000 -0800
+++ binutils-psp/include/opcode/mips.h	2005-08-22 09:14:58.043553112 -0700
@@ -171,6 +171,83 @@
 #define MDMX_FMTSEL_VEC_QH	0x15
 #define MDMX_FMTSEL_VEC_OB	0x16
 
+#define OP_SH_VFPU_DELTA	0
+#define OP_MASK_VFPU_DELTA	0xfffc
+#define OP_SH_VFPU_IMM3		16
+#define OP_MASK_VFPU_IMM3	0x7
+#define OP_SH_VFPU_IMM5		16
+#define OP_MASK_VFPU_IMM5	0x1f
+#define OP_SH_VFPU_IMM8		16
+#define OP_MASK_VFPU_IMM8	0xff
+#define OP_SH_VFPU_CC		18	/* Condition code. */
+#define OP_MASK_VFPU_CC		0x7
+#define OP_SH_VFPU_CONST	16
+#define OP_MASK_VFPU_CONST	0x1f
+#define OP_SH_VFPU_COND		0	/* Conditional compare. */
+#define OP_MASK_VFPU_COND	0xf
+#define OP_SH_VFPU_VMTVC	0
+#define OP_MASK_VFPU_VMTVC	0xff
+#define OP_SH_VFPU_VMFVC	8
+#define OP_MASK_VFPU_VMFVC	0xff
+#define OP_SH_VFPU_RWB		1
+#define OP_MASK_VFPU_RWB	0x1
+#define OP_SH_VFPU_ROT		16	/* Rotators used in vrot. */
+#define OP_MASK_VFPU_ROT	0x1f
+#define OP_SH_VFPU_FLOAT16	0
+#define OP_MASK_VFPU_FLOAT16	0xffff
+
+/* VFPU registers. */
+#define OP_SH_VFPU_VD		0
+#define OP_MASK_VFPU_VD		0x7f
+#define OP_SH_VFPU_VS		8
+#define OP_MASK_VFPU_VS		0x7f
+#define OP_SH_VFPU_VT		16
+#define OP_MASK_VFPU_VT		0x7f
+#define OP_SH_VFPU_VT_LO	16	/* Bits 0-4 of vt. */
+#define OP_MASK_VFPU_VT_LO	0x1f
+#define OP_SH_VFPU_VT_HI	5	/* Right-shifted. */
+#define OP_MASK_VFPU_VT_HI1	0x1	/* Bit 5 of vt. */
+#define OP_MASK_VFPU_VT_HI2	0x3	/* Bits 5-6 of vt. */
+/* Special handling of vs in vmmul instructions. */
+#define VFPU_OP_VT_VS_VD	0xff800000
+#define VFPU_OPCODE_VMMUL	0xf0000000
+
+/* VFPU prefix instruction operands.  The *_SH_* values really specify where
+   the bitfield begins, as VFPU prefix instructions have four operands
+   encoded within the immediate field. */
+#define VFPU_SH_PFX_NEG		16
+#define VFPU_MASK_PFX_NEG	0x1	/* Negation. */
+#define VFPU_SH_PFX_CST		12
+#define VFPU_MASK_PFX_CST	0x1	/* Constant. */
+#define VFPU_SH_PFX_ABS_CSTHI	8
+#define VFPU_MASK_PFX_ABS_CSTHI	0x1	/* Abs/Constant (bit 2). */
+#define VFPU_MASK_PFX_SWZ_CSTLO	0x3	/* Swizzle/Constant (bits 0-1). */
+#define VFPU_SH_PFX_MASK	8
+#define VFPU_MASK_PFX_MASK	0x1	/* Mask. */
+#define VFPU_MASK_PFX_SAT	0x3	/* Saturation. */
+
+/* Special handling of the vrot instructions. */
+#define VFPU_MASK_OP_SIZE	0x8080	/* Masks the operand size (pair, triple, quad). */
+#define VFPU_OP_SIZE_PAIR	0x80
+#define VFPU_OP_SIZE_TRIPLE	0x8000
+#define VFPU_OP_SIZE_QUAD	0x8080
+/* Note that these are within the rotators field, and not the full opcode. */
+#define VFPU_SH_ROT_HI		2
+#define VFPU_MASK_ROT_HI	0x3
+#define VFPU_SH_ROT_LO		0
+#define VFPU_MASK_ROT_LO	0x3
+#define VFPU_SH_ROT_NEG		4	/* Negation. */
+#define VFPU_MASK_ROT_NEG	0x1
+
+/* VFPU 16-bit floating-point format. */
+#define VFPU_FLOAT16_EXP_MAX	0x1f
+#define VFPU_SH_FLOAT16_SIGN	15
+#define VFPU_MASK_FLOAT16_SIGN	0x1
+#define VFPU_SH_FLOAT16_EXP	10
+#define VFPU_MASK_FLOAT16_EXP	0x1f
+#define VFPU_SH_FLOAT16_FRAC	0
+#define VFPU_MASK_FLOAT16_FRAC	0x3ff
+
 /* This structure holds information for a particular instruction.  */
 
 struct mips_opcode
@@ -258,6 +335,29 @@
 	Requires that "+A" or "+E" occur first to set position.
 	Enforces: 32 < (pos+size) <= 64.
 
+   Sony Allegrex VFPU instructions:
+   "?o"
+   "?0" - "?3"
+   "?4" - "?7"
+   "?a"
+   "?b"
+   "?c"
+   "?e"
+   "?f"
+   "?i"
+   "?q"
+   "?r"
+   "?u"
+   "?w"
+   "?d"
+   "?m"
+   "?n"
+   "?s"
+   "?t"
+   "?v"
+   "?x"
+   "?z"
+
    Floating point instructions:
    "D" 5 bit destination register (OP_*_FD)
    "M" 3 bit compare condition code (OP_*_CCC) (only used for mips4 and up)
@@ -442,6 +542,8 @@
 #define INSN_5400		  0x01000000
 /* NEC VR5500 instruction.  */
 #define INSN_5500		  0x02000000
+/* Sony Allegrex instruction.  */
+#define INSN_ALLEGREX		  0x10000000
 
 /* MIPS ISA defines, use instead of hardcoding ISA level.  */
 
@@ -489,6 +591,7 @@
 #define CPU_MIPS64      64
 #define CPU_MIPS64R2	65
 #define CPU_SB1         12310201        /* octal 'SB', 01.  */
+#define CPU_ALLEGREX    10111431        /* octal 'AL', 31.  */
 
 /* Test for membership in an ISA including chip specific ISAs.  INSN
    is pointer to an element of the opcode table; ISA is the specified
@@ -510,6 +613,7 @@
      || (cpu == CPU_VR4120 && ((insn)->membership & INSN_4120) != 0)	\
      || (cpu == CPU_VR5400 && ((insn)->membership & INSN_5400) != 0)	\
      || (cpu == CPU_VR5500 && ((insn)->membership & INSN_5500) != 0)	\
+     || (cpu == CPU_ALLEGREX && ((insn)->membership & INSN_ALLEGREX) != 0)	\
      || 0)	/* Please keep this term for easier source merging.  */
 
 /* This is a list of macro expanded instructions.
@@ -625,6 +729,16 @@
   M_LL_AB,
   M_LLD_AB,
   M_LS_A,
+  M_LVHIP,
+  M_LVHIS,
+  M_LVIP,
+  M_LVIQ,
+  M_LVIS,
+  M_LVIT,
+  M_LVLQ_AB,
+  M_LVRQ_AB,
+  M_LVQ_AB,
+  M_LVQ_AB_2,
   M_LW_A,
   M_LW_AB,
   M_LWC0_A,
@@ -714,6 +828,10 @@
   M_SUB_I,
   M_SUBU_I,
   M_SUBU_I_2,
+  M_SVLQ_AB,
+  M_SVQ_AB,
+  M_SVRQ_AB,
+  M_SVS_AB,
   M_TEQ_I,
   M_TGE_I,
   M_TGEU_I,
@@ -728,14 +846,24 @@
   M_ULH_A,
   M_ULHU,
   M_ULHU_A,
+  M_ULVQ,
+  M_ULVQ_AB,
+  M_ULVS,
   M_ULW,
   M_ULW_A,
   M_USH,
   M_USH_A,
+  M_USVQ,
+  M_USVQ_AB,
+  M_USVS,
   M_USW,
   M_USW_A,
   M_USD,
   M_USD_A,
+  M_VCMOVP,
+  M_VCMOVQ,
+  M_VCMOVS,
+  M_VCMOVT,
   M_XOR_I,
   M_COP0,
   M_COP1,
--- binutils-2.16.orig/include/bin-bugs.h	2004-07-23 08:40:19.000000000 -0700
+++ binutils-psp/include/bin-bugs.h	2005-07-22 22:38:52.000000000 -0700
@@ -1,3 +1,3 @@
 #ifndef REPORT_BUGS_TO
-#define REPORT_BUGS_TO	"<URL:http://www.sourceware.org/bugzilla/>"
+#define REPORT_BUGS_TO	"<URL:http://wiki.pspdev.org/psp:toolchain#bugs>"
 #endif
--- binutils-2.16.orig/ld/Makefile.am	2005-01-20 11:37:49.000000000 -0800
+++ binutils-psp/ld/Makefile.am	2005-06-25 02:44:52.000000000 -0700
@@ -190,6 +190,7 @@
 	eelf_i386_chaos.o \
 	eelf_i386_fbsd.o \
 	eelf_i386_ldso.o \
+	eelf_mipsallegrexel_psp.o \
 	eelf_s390.o \
 	egld960.o \
 	egld960coff.o \
@@ -864,6 +865,9 @@
 eelf_i386_ldso.c: $(srcdir)/emulparams/elf_i386_ldso.sh \
   $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} elf_i386_ldso "$(tdir_elf_i386_ldso)"
+eelf_mipsallegrexel_psp.c: $(srcdir)/emulparams/elf_mipsallegrexel_psp.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf_psp.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf_mipsallegrexel_psp "$(tdir_elf_mipsallegrexel_psp)"
 eelf_s390.c: $(srcdir)/emulparams/elf_s390.sh \
   $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} elf_s390 "$(tdir_elf_s390)"
--- binutils-2.16.orig/ld/Makefile.in	2005-01-22 21:36:37.000000000 -0800
+++ binutils-psp/ld/Makefile.in	2005-06-25 02:47:12.000000000 -0700
@@ -315,6 +315,7 @@
 	eelf_i386_chaos.o \
 	eelf_i386_fbsd.o \
 	eelf_i386_ldso.o \
+	eelf_mipsallegrexel_psp.o \
 	eelf_s390.o \
 	egld960.o \
 	egld960coff.o \
@@ -1601,6 +1602,9 @@
 eelf_i386_ldso.c: $(srcdir)/emulparams/elf_i386_ldso.sh \
   $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} elf_i386_ldso "$(tdir_elf_i386_ldso)"
+eelf_mipsallegrexel_psp.c: $(srcdir)/emulparams/elf_mipsallegrexel_psp.sh \
+  $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf_psp.sc ${GEN_DEPENDS}
+	${GENSCRIPTS} elf_mipsallegrexel_psp "$(tdir_elf_mipsallegrexel_psp)"
 eelf_s390.c: $(srcdir)/emulparams/elf_s390.sh \
   $(srcdir)/emultempl/elf32.em $(srcdir)/scripttempl/elf.sc ${GEN_DEPENDS}
 	${GENSCRIPTS} elf_s390 "$(tdir_elf_s390)"
--- binutils-2.16.orig/ld/configure.tgt	2005-02-08 11:54:27.000000000 -0800
+++ binutils-psp/ld/configure.tgt	2005-06-25 03:20:06.000000000 -0700
@@ -428,6 +428,8 @@
 mips*vr4100-*-elf*)	targ_emul=elf32b4300 ;;
 mips*vr5000el-*-elf*)	targ_emul=elf32l4300 ;;
 mips*vr5000-*-elf*)	targ_emul=elf32b4300 ;;
+mips*allegrexel-psp-elf*) targ_emul=elf_mipsallegrexel_psp
+			targ_extra_emuls="elf32elmip" ;;
 mips*el-*-elf*)		targ_emul=elf32elmip ;;
 mips*-*-elf*)		targ_emul=elf32ebmip ;;
 mips*el-*-rtems*)	targ_emul=elf32elmip ;;
--- binutils-2.16.orig/ld/emulparams/elf_mipsallegrexel_psp.sh	1969-12-31 16:00:00.000000000 -0800
+++ binutils-psp/ld/emulparams/elf_mipsallegrexel_psp.sh	2005-07-12 03:44:26.000000000 -0700
@@ -0,0 +1,22 @@
+# Based off of the default elf32 MIPS target.  However, we use a seperate
+# script template because the PSP architecture defines sections that normally
+# cannot be overriden here and would normally get absorbed (i.e.
+# .rodata.sceModuleInfo would be absorbed into .rodata).
+
+EMBEDDED=yes
+. ${srcdir}/emulparams/elf32lmip.sh
+unset NONPAGED_TEXT_START_ADDR
+unset SHLIB_TEXT_START_ADDR
+unset COMMONPAGESIZE
+
+SCRIPT_NAME=elf_psp
+TEXT_START_ADDR=0x08900000
+MAXPAGESIZE=256
+ARCH="mips:allegrex"
+MACHINE=
+TEMPLATE_NAME=elf32
+GENERATE_SHLIB_SCRIPT=yes
+DYNAMIC_LINK=FALSE
+
+# Discard the .comment and .pdr sections.
+OTHER_SECTIONS="/DISCARD/ : { *(.comment) *(.pdr) }"
--- binutils-2.16.orig/ld/scripttempl/elf_psp.sc	1969-12-31 16:00:00.000000000 -0800
+++ binutils-psp/ld/scripttempl/elf_psp.sc	2005-06-25 03:12:02.000000000 -0700
@@ -0,0 +1,496 @@
+#
+# Unusual variables checked by this code:
+#	NOP - four byte opcode for no-op (defaults to 0)
+#	NO_SMALL_DATA - no .sbss/.sbss2/.sdata/.sdata2 sections if not
+#		empty.
+#	SMALL_DATA_CTOR - .ctors contains small data.
+#	SMALL_DATA_DTOR - .dtors contains small data.
+#	DATA_ADDR - if end-of-text-plus-one-page isn't right for data start
+#	INITIAL_READONLY_SECTIONS - at start of text segment
+#	OTHER_READONLY_SECTIONS - other than .text .init .rodata ...
+#		(e.g., .PARISC.milli)
+#	OTHER_TEXT_SECTIONS - these get put in .text when relocating
+#	OTHER_READWRITE_SECTIONS - other than .data .bss .ctors .sdata ...
+#		(e.g., .PARISC.global)
+#	OTHER_RELRO_SECTIONS - other than .data.rel.ro ...
+#		(e.g. PPC32 .fixup, .got[12])
+#	OTHER_BSS_SECTIONS - other than .bss .sbss ...
+#	OTHER_SECTIONS - at the end
+#	EXECUTABLE_SYMBOLS - symbols that must be defined for an
+#		executable (e.g., _DYNAMIC_LINK)
+#       TEXT_START_ADDR - the first byte of the text segment, after any
+#               headers.
+#       TEXT_BASE_ADDRESS - the first byte of the text segment.
+#	TEXT_START_SYMBOLS - symbols that appear at the start of the
+#		.text section.
+#	DATA_START_SYMBOLS - symbols that appear at the start of the
+#		.data section.
+#	OTHER_GOT_SYMBOLS - symbols defined just before .got.
+#	OTHER_GOT_SECTIONS - sections just after .got.
+#	OTHER_SDATA_SECTIONS - sections just after .sdata.
+#	OTHER_BSS_SYMBOLS - symbols that appear at the start of the
+#		.bss section besides __bss_start.
+#	DATA_PLT - .plt should be in data segment, not text segment.
+#	PLT_BEFORE_GOT - .plt just before .got when .plt is in data segement.
+#	BSS_PLT - .plt should be in bss segment
+#	TEXT_DYNAMIC - .dynamic in text segment, not data segment.
+#	EMBEDDED - whether this is for an embedded system. 
+#	SHLIB_TEXT_START_ADDR - if set, add to SIZEOF_HEADERS to set
+#		start address of shared library.
+#	INPUT_FILES - INPUT command of files to always include
+#	WRITABLE_RODATA - if set, the .rodata section should be writable
+#	INIT_START, INIT_END -  statements just before and just after
+# 	combination of .init sections.
+#	FINI_START, FINI_END - statements just before and just after
+# 	combination of .fini sections.
+#	STACK_ADDR - start of a .stack section.
+#	OTHER_END_SYMBOLS - symbols to place right at the end of the script.
+#	SEPARATE_GOTPLT - if set, .got.plt should be separate output section,
+#		so that .got can be in the RELRO area.  It should be set to
+#		the number of bytes in the beginning of .got.plt which can be
+#		in the RELRO area as well.
+#
+# When adding sections, do note that the names of some sections are used
+# when specifying the start address of the next.
+#
+
+#  Many sections come in three flavours.  There is the 'real' section,
+#  like ".data".  Then there are the per-procedure or per-variable
+#  sections, generated by -ffunction-sections and -fdata-sections in GCC,
+#  and useful for --gc-sections, which for a variable "foo" might be
+#  ".data.foo".  Then there are the linkonce sections, for which the linker
+#  eliminates duplicates, which are named like ".gnu.linkonce.d.foo".
+#  The exact correspondences are:
+#
+#  Section	Linkonce section
+#  .text	.gnu.linkonce.t.foo
+#  .rodata	.gnu.linkonce.r.foo
+#  .data	.gnu.linkonce.d.foo
+#  .bss		.gnu.linkonce.b.foo
+#  .sdata	.gnu.linkonce.s.foo
+#  .sbss	.gnu.linkonce.sb.foo
+#  .sdata2	.gnu.linkonce.s2.foo
+#  .sbss2	.gnu.linkonce.sb2.foo
+#  .debug_info	.gnu.linkonce.wi.foo
+#  .tdata	.gnu.linkonce.td.foo
+#  .tbss	.gnu.linkonce.tb.foo
+#
+#  Each of these can also have corresponding .rel.* and .rela.* sections.
+
+test -z "$ENTRY" && ENTRY=_start
+test -z "${BIG_OUTPUT_FORMAT}" && BIG_OUTPUT_FORMAT=${OUTPUT_FORMAT}
+test -z "${LITTLE_OUTPUT_FORMAT}" && LITTLE_OUTPUT_FORMAT=${OUTPUT_FORMAT}
+if [ -z "$MACHINE" ]; then OUTPUT_ARCH=${ARCH}; else OUTPUT_ARCH=${ARCH}:${MACHINE}; fi
+test -z "${ELFSIZE}" && ELFSIZE=32
+test -z "${ALIGNMENT}" && ALIGNMENT="${ELFSIZE} / 8"
+test "$LD_FLAG" = "N" && DATA_ADDR=.
+test -n "$CREATE_SHLIB$CREATE_PIE" && test -n "$SHLIB_DATA_ADDR" && COMMONPAGESIZE=""
+test -z "$CREATE_SHLIB$CREATE_PIE" && test -n "$DATA_ADDR" && COMMONPAGESIZE=""
+test -n "$RELRO_NOW" && unset SEPARATE_GOTPLT
+DATA_SEGMENT_ALIGN="ALIGN(${SEGMENT_SIZE}) + (. & (${MAXPAGESIZE} - 1))"
+DATA_SEGMENT_RELRO_END=""
+DATA_SEGMENT_RELRO_GOTPLT_END=""
+DATA_SEGMENT_END=""
+if test -n "${COMMONPAGESIZE}"; then
+  DATA_SEGMENT_ALIGN="ALIGN (${SEGMENT_SIZE}) - ((${MAXPAGESIZE} - .) & (${MAXPAGESIZE} - 1)); . = DATA_SEGMENT_ALIGN (${MAXPAGESIZE}, ${COMMONPAGESIZE})"
+  DATA_SEGMENT_END=". = DATA_SEGMENT_END (.);"
+  if test -n "${SEPARATE_GOTPLT}"; then
+    DATA_SEGMENT_RELRO_GOTPLT_END=". = DATA_SEGMENT_RELRO_END (${SEPARATE_GOTPLT}, .);"
+  else
+    DATA_SEGMENT_RELRO_END=". = DATA_SEGMENT_RELRO_END (0, .);"
+  fi
+fi
+INTERP=".interp       ${RELOCATING-0} : { *(.interp) }"
+PLT=".plt          ${RELOCATING-0} : { *(.plt) }"
+if test -z "$GOT"; then
+  if test -z "$SEPARATE_GOTPLT"; then
+    GOT=".got          ${RELOCATING-0} : { *(.got.plt) *(.got) }"
+  else
+    GOT=".got          ${RELOCATING-0} : { *(.got) }"
+    GOTPLT="${RELOCATING+${DATA_SEGMENT_RELRO_GOTPLT_END}}
+  .got.plt      ${RELOCATING-0} : { *(.got.plt) }"
+  fi
+fi
+DYNAMIC=".dynamic      ${RELOCATING-0} : { *(.dynamic) }"
+RODATA=".rodata       ${RELOCATING-0} : { *(.rodata${RELOCATING+ .rodata.* .gnu.linkonce.r.*}) }"
+DATARELRO=".data.rel.ro : { *(.data.rel.ro.local) *(.data.rel.ro*) }"
+STACKNOTE="/DISCARD/ : { *(.note.GNU-stack) }"
+if test -z "${NO_SMALL_DATA}"; then
+  SBSS=".sbss         ${RELOCATING-0} :
+  {
+    ${RELOCATING+PROVIDE (__sbss_start = .);}
+    ${RELOCATING+PROVIDE (___sbss_start = .);}
+    ${CREATE_SHLIB+*(.sbss2 .sbss2.* .gnu.linkonce.sb2.*)}
+    *(.dynsbss)
+    *(.sbss${RELOCATING+ .sbss.* .gnu.linkonce.sb.*})
+    *(.scommon)
+    ${RELOCATING+PROVIDE (__sbss_end = .);}
+    ${RELOCATING+PROVIDE (___sbss_end = .);}
+  }"
+  SBSS2=".sbss2        ${RELOCATING-0} : { *(.sbss2${RELOCATING+ .sbss2.* .gnu.linkonce.sb2.*}) }"
+  SDATA="/* We want the small data sections together, so single-instruction offsets
+     can access them all, and initialized data all before uninitialized, so
+     we can shorten the on-disk segment size.  */
+  .sdata        ${RELOCATING-0} : 
+  {
+    ${RELOCATING+${SDATA_START_SYMBOLS}}
+    ${CREATE_SHLIB+*(.sdata2 .sdata2.* .gnu.linkonce.s2.*)}
+    *(.sdata${RELOCATING+ .sdata.* .gnu.linkonce.s.*})
+  }"
+  SDATA2=".sdata2       ${RELOCATING-0} : { *(.sdata2${RELOCATING+ .sdata2.* .gnu.linkonce.s2.*}) }"
+  REL_SDATA=".rel.sdata    ${RELOCATING-0} : { *(.rel.sdata${RELOCATING+ .rel.sdata.* .rel.gnu.linkonce.s.*}) }
+  .rela.sdata   ${RELOCATING-0} : { *(.rela.sdata${RELOCATING+ .rela.sdata.* .rela.gnu.linkonce.s.*}) }"
+  REL_SBSS=".rel.sbss     ${RELOCATING-0} : { *(.rel.sbss${RELOCATING+ .rel.sbss.* .rel.gnu.linkonce.sb.*}) }
+  .rela.sbss    ${RELOCATING-0} : { *(.rela.sbss${RELOCATING+ .rela.sbss.* .rela.gnu.linkonce.sb.*}) }"
+  REL_SDATA2=".rel.sdata2   ${RELOCATING-0} : { *(.rel.sdata2${RELOCATING+ .rel.sdata2.* .rel.gnu.linkonce.s2.*}) }
+  .rela.sdata2  ${RELOCATING-0} : { *(.rela.sdata2${RELOCATING+ .rela.sdata2.* .rela.gnu.linkonce.s2.*}) }"
+  REL_SBSS2=".rel.sbss2    ${RELOCATING-0} : { *(.rel.sbss2${RELOCATING+ .rel.sbss2.* .rel.gnu.linkonce.sb2.*}) }
+  .rela.sbss2   ${RELOCATING-0} : { *(.rela.sbss2${RELOCATING+ .rela.sbss2.* .rela.gnu.linkonce.sb2.*}) }"
+else
+  NO_SMALL_DATA=" "
+fi
+test -n "$SEPARATE_GOTPLT" && SEPARATE_GOTPLT=" "
+CTOR=".ctors        ${CONSTRUCTING-0} : 
+  {
+    ${CONSTRUCTING+${CTOR_START}}
+    /* gcc uses crtbegin.o to find the start of
+       the constructors, so we make sure it is
+       first.  Because this is a wildcard, it
+       doesn't matter if the user does not
+       actually link against crtbegin.o; the
+       linker won't look for a file to match a
+       wildcard.  The wildcard also means that it
+       doesn't matter which directory crtbegin.o
+       is in.  */
+
+    KEEP (*crtbegin*.o(.ctors))
+
+    /* We don't want to include the .ctor section from
+       from the crtend.o file until after the sorted ctors.
+       The .ctor section from the crtend file contains the
+       end of ctors marker and it must be last */
+
+    KEEP (*(EXCLUDE_FILE (*crtend*.o $OTHER_EXCLUDE_FILES) .ctors))
+    KEEP (*(SORT(.ctors.*)))
+    KEEP (*(.ctors))
+    ${CONSTRUCTING+${CTOR_END}}
+  }"
+DTOR=".dtors        ${CONSTRUCTING-0} :
+  {
+    ${CONSTRUCTING+${DTOR_START}}
+    KEEP (*crtbegin*.o(.dtors))
+    KEEP (*(EXCLUDE_FILE (*crtend*.o $OTHER_EXCLUDE_FILES) .dtors))
+    KEEP (*(SORT(.dtors.*)))
+    KEEP (*(.dtors))
+    ${CONSTRUCTING+${DTOR_END}}
+  }"
+STACK="  .stack        ${RELOCATING-0}${RELOCATING+${STACK_ADDR}} :
+  {
+    ${RELOCATING+_stack = .;}
+    *(.stack)
+  }"
+
+# if this is for an embedded system, don't add SIZEOF_HEADERS.
+if [ -z "$EMBEDDED" ]; then
+   test -z "${TEXT_BASE_ADDRESS}" && TEXT_BASE_ADDRESS="${TEXT_START_ADDR} + SIZEOF_HEADERS"
+else
+   test -z "${TEXT_BASE_ADDRESS}" && TEXT_BASE_ADDRESS="${TEXT_START_ADDR}"
+fi
+
+cat <<EOF
+OUTPUT_FORMAT("${OUTPUT_FORMAT}", "${BIG_OUTPUT_FORMAT}",
+	      "${LITTLE_OUTPUT_FORMAT}")
+OUTPUT_ARCH(${OUTPUT_ARCH})
+ENTRY(${ENTRY})
+
+${RELOCATING+${LIB_SEARCH_DIRS}}
+${RELOCATING+/* Do we need any of these for elf?
+   __DYNAMIC = 0; ${STACKZERO+${STACKZERO}} ${SHLIB_PATH+${SHLIB_PATH}}  */}
+${RELOCATING+${EXECUTABLE_SYMBOLS}}
+${RELOCATING+${INPUT_FILES}}
+${RELOCATING- /* For some reason, the Solaris linker makes bad executables
+  if gld -r is used and the intermediate file has sections starting
+  at non-zero addresses.  Could be a Solaris ld bug, could be a GNU ld
+  bug.  But for now assigning the zero vmas works.  */}
+
+SECTIONS
+{
+  /* Read-only sections, merged into text segment: */
+  ${CREATE_SHLIB-${CREATE_PIE-${RELOCATING+PROVIDE (__executable_start = ${TEXT_START_ADDR}); . = ${TEXT_BASE_ADDRESS};}}}
+  ${CREATE_SHLIB+${RELOCATING+. = ${SHLIB_TEXT_START_ADDR:-0} + SIZEOF_HEADERS;}}
+  ${CREATE_PIE+${RELOCATING+. = ${SHLIB_TEXT_START_ADDR:-0} + SIZEOF_HEADERS;}}
+  ${CREATE_SHLIB-${INTERP}}
+  ${INITIAL_READONLY_SECTIONS}
+  ${TEXT_DYNAMIC+${DYNAMIC}}
+  .hash         ${RELOCATING-0} : { *(.hash) }
+  .dynsym       ${RELOCATING-0} : { *(.dynsym) }
+  .dynstr       ${RELOCATING-0} : { *(.dynstr) }
+  .gnu.version  ${RELOCATING-0} : { *(.gnu.version) }
+  .gnu.version_d ${RELOCATING-0}: { *(.gnu.version_d) }
+  .gnu.version_r ${RELOCATING-0}: { *(.gnu.version_r) }
+
+EOF
+if [ "x$COMBRELOC" = x ]; then
+  COMBRELOCCAT=cat
+else
+  COMBRELOCCAT="cat > $COMBRELOC"
+fi
+eval $COMBRELOCCAT <<EOF
+  .rel.init     ${RELOCATING-0} : { *(.rel.init) }
+  .rela.init    ${RELOCATING-0} : { *(.rela.init) }
+  .rel.text     ${RELOCATING-0} : { *(.rel.text${RELOCATING+ .rel.text.* .rel.gnu.linkonce.t.*}) }
+  .rela.text    ${RELOCATING-0} : { *(.rela.text${RELOCATING+ .rela.text.* .rela.gnu.linkonce.t.*}) }
+  .rel.fini     ${RELOCATING-0} : { *(.rel.fini) }
+  .rela.fini    ${RELOCATING-0} : { *(.rela.fini) }
+
+  /* PSP-specific relocations. */
+  .rel.sceStub.text ${RELOCATING-0} : { *(.rel.sceStub.text) *(SORT(.rel.sceStub.text.*)) }
+  .rel.lib.ent.top  ${RELOCATING-0} : { *(.rel.lib.ent.top) }
+  .rel.lib.ent      ${RELOCATING-0} : { *(.rel.lib.ent) }
+  .rel.lib.ent.btm  ${RELOCATING-0} : { *(.rel.lib.ent.btm) }
+  .rel.lib.stub.top ${RELOCATING-0} : { *(.rel.lib.stub.top) }
+  .rel.lib.stub     ${RELOCATING-0} : { *(.rel.lib.stub) }
+  .rel.lib.stub.btm ${RELOCATING-0} : { *(.rel.lib.stub.btm) }
+  .rel.rodata.sceModuleInfo ${RELOCATING-0} : { *(.rel.rodata.sceModuleInfo) }
+  .rel.rodata.sceResident   ${RELOCATING-0} : { *(.rel.rodata.sceResident) }
+  .rel.rodata.sceNid        ${RELOCATING-0} : { *(.rel.rodata.sceNid) }
+  .rel.rodata.sceVstub      ${RELOCATING-0} : { *(.rel.rodata.sceVstub) *(SORT(.rel.rodata.sceVstub.*)) }
+
+  .rel.rodata   ${RELOCATING-0} : { *(.rel.rodata${RELOCATING+ .rel.rodata.* .rel.gnu.linkonce.r.*}) }
+  .rela.rodata  ${RELOCATING-0} : { *(.rela.rodata${RELOCATING+ .rela.rodata.* .rela.gnu.linkonce.r.*}) }
+  ${OTHER_READONLY_RELOC_SECTIONS}
+  .rel.data.rel.ro ${RELOCATING-0} : { *(.rel.data.rel.ro${RELOCATING+*}) }
+  .rela.data.rel.ro ${RELOCATING-0} : { *(.rel.data.rel.ro${RELOCATING+*}) }
+  .rel.data     ${RELOCATING-0} : { *(.rel.data${RELOCATING+ .rel.data.* .rel.gnu.linkonce.d.*}) }
+  .rela.data    ${RELOCATING-0} : { *(.rela.data${RELOCATING+ .rela.data.* .rela.gnu.linkonce.d.*}) }
+  .rel.tdata	${RELOCATING-0} : { *(.rel.tdata${RELOCATING+ .rel.tdata.* .rel.gnu.linkonce.td.*}) }
+  .rela.tdata	${RELOCATING-0} : { *(.rela.tdata${RELOCATING+ .rela.tdata.* .rela.gnu.linkonce.td.*}) }
+  .rel.tbss	${RELOCATING-0} : { *(.rel.tbss${RELOCATING+ .rel.tbss.* .rel.gnu.linkonce.tb.*}) }
+  .rela.tbss	${RELOCATING-0} : { *(.rela.tbss${RELOCATING+ .rela.tbss.* .rela.gnu.linkonce.tb.*}) }
+  .rel.ctors    ${RELOCATING-0} : { *(.rel.ctors) }
+  .rela.ctors   ${RELOCATING-0} : { *(.rela.ctors) }
+  .rel.dtors    ${RELOCATING-0} : { *(.rel.dtors) }
+  .rela.dtors   ${RELOCATING-0} : { *(.rela.dtors) }
+  .rel.got      ${RELOCATING-0} : { *(.rel.got) }
+  .rela.got     ${RELOCATING-0} : { *(.rela.got) }
+  ${OTHER_GOT_RELOC_SECTIONS}
+  ${REL_SDATA}
+  ${REL_SBSS}
+  ${REL_SDATA2}
+  ${REL_SBSS2}
+  .rel.bss      ${RELOCATING-0} : { *(.rel.bss${RELOCATING+ .rel.bss.* .rel.gnu.linkonce.b.*}) }
+  .rela.bss     ${RELOCATING-0} : { *(.rela.bss${RELOCATING+ .rela.bss.* .rela.gnu.linkonce.b.*}) }
+EOF
+if [ -n "$COMBRELOC" ]; then
+cat <<EOF
+  .rel.dyn      ${RELOCATING-0} :
+    {
+EOF
+sed -e '/^[ 	]*[{}][ 	]*$/d;/:[ 	]*$/d;/\.rela\./d;s/^.*: { *\(.*\)}$/      \1/' $COMBRELOC
+cat <<EOF
+    }
+  .rela.dyn     ${RELOCATING-0} :
+    {
+EOF
+sed -e '/^[ 	]*[{}][ 	]*$/d;/:[ 	]*$/d;/\.rel\./d;s/^.*: { *\(.*\)}/      \1/' $COMBRELOC
+cat <<EOF
+    }
+EOF
+fi
+cat <<EOF
+  .rel.plt      ${RELOCATING-0} : { *(.rel.plt) }
+  .rela.plt     ${RELOCATING-0} : { *(.rela.plt) }
+  ${OTHER_PLT_RELOC_SECTIONS}
+
+  .init         ${RELOCATING-0} : 
+  { 
+    ${RELOCATING+${INIT_START}}
+    KEEP (*(.init))
+    ${RELOCATING+${INIT_END}}
+  } =${NOP-0}
+
+  ${DATA_PLT-${BSS_PLT-${PLT}}}
+  .text         ${RELOCATING-0} :
+  {
+    ${RELOCATING+${TEXT_START_SYMBOLS}}
+    *(.text .stub${RELOCATING+ .text.* .gnu.linkonce.t.*})
+    KEEP (*(.text.*personality*))
+    /* .gnu.warning sections are handled specially by elf32.em.  */
+    *(.gnu.warning)
+    ${RELOCATING+${OTHER_TEXT_SECTIONS}}
+  } =${NOP-0}
+  .fini         ${RELOCATING-0} :
+  {
+    ${RELOCATING+${FINI_START}}
+    KEEP (*(.fini))
+    ${RELOCATING+${FINI_END}}
+  } =${NOP-0}
+
+  /* PSP library stub functions. */
+  .sceStub.text   ${RELOCATING-0} : { *(.sceStub.text) *(SORT(.sceStub.text.*)) }
+
+  ${RELOCATING+PROVIDE (__etext = .);}
+  ${RELOCATING+PROVIDE (_etext = .);}
+  ${RELOCATING+PROVIDE (etext = .);}
+
+  /* PSP library entry table and library stub table. */
+  .lib.ent.top  ${RELOCATING-0} : { *(.lib.ent.top) }
+  .lib.ent      ${RELOCATING-0} : { *(.lib.ent) }
+  .lib.ent.btm  ${RELOCATING-0} : { *(.lib.ent.btm) }
+
+  .lib.stub.top ${RELOCATING-0} : { *(.lib.stub.top) }
+  .lib.stub     ${RELOCATING-0} : { *(.lib.stub) }
+  .lib.stub.btm ${RELOCATING-0} : { *(.lib.stub.btm) }
+
+  /* PSP read-only data for module info, NIDs, and Vstubs.  The
+     .rodata.sceModuleInfo section must appear before the .rodata section
+     otherwise it would get absorbed into .rodata and the PSP bootloader
+     would be unable to locate the module info structure. */
+  .rodata.sceModuleInfo  ${RELOCATING-0} : { *(.rodata.sceModuleInfo) }
+  .rodata.sceResident    ${RELOCATING-0} : { *(.rodata.sceResident) }
+  .rodata.sceNid         ${RELOCATING-0} : { *(.rodata.sceNid) }
+  .rodata.sceVstub       ${RELOCATING-0} : { *(.rodata.sceVstub) *(SORT(.rodata.sceVstub.*)) }
+
+  ${WRITABLE_RODATA-${RODATA}}
+  .rodata1      ${RELOCATING-0} : { *(.rodata1) }
+  ${CREATE_SHLIB-${SDATA2}}
+  ${CREATE_SHLIB-${SBSS2}}
+  ${OTHER_READONLY_SECTIONS}
+  .eh_frame_hdr : { *(.eh_frame_hdr) }
+  .eh_frame     ${RELOCATING-0} : ONLY_IF_RO { KEEP (*(.eh_frame)) }
+  .gcc_except_table ${RELOCATING-0} : ONLY_IF_RO { KEEP (*(.gcc_except_table)) *(.gcc_except_table.*) }
+
+  /* Adjust the address for the data segment.  We want to adjust up to
+     the same address within the page on the next page up.  */
+  ${CREATE_SHLIB-${CREATE_PIE-${RELOCATING+. = ${DATA_ADDR-${DATA_SEGMENT_ALIGN}};}}}
+  ${CREATE_SHLIB+${RELOCATING+. = ${SHLIB_DATA_ADDR-${DATA_SEGMENT_ALIGN}};}}
+  ${CREATE_PIE+${RELOCATING+. = ${SHLIB_DATA_ADDR-${DATA_SEGMENT_ALIGN}};}}
+
+  /* Exception handling  */
+  .eh_frame     ${RELOCATING-0} : ONLY_IF_RW { KEEP (*(.eh_frame)) }
+  .gcc_except_table ${RELOCATING-0} : ONLY_IF_RW { KEEP (*(.gcc_except_table)) *(.gcc_except_table.*) }
+
+  /* Thread Local Storage sections  */
+  .tdata	${RELOCATING-0} : { *(.tdata${RELOCATING+ .tdata.* .gnu.linkonce.td.*}) }
+  .tbss		${RELOCATING-0} : { *(.tbss${RELOCATING+ .tbss.* .gnu.linkonce.tb.*})${RELOCATING+ *(.tcommon)} }
+
+  /* Ensure the __preinit_array_start label is properly aligned.  We
+     could instead move the label definition inside the section, but
+     the linker would then create the section even if it turns out to
+     be empty, which isn't pretty.  */
+  ${RELOCATING+. = ALIGN(${ALIGNMENT});}
+  ${RELOCATING+${CREATE_SHLIB-PROVIDE (__preinit_array_start = .);}}
+  .preinit_array   ${RELOCATING-0} : { KEEP (*(.preinit_array)) }
+  ${RELOCATING+${CREATE_SHLIB-PROVIDE (__preinit_array_end = .);}}
+
+  ${RELOCATING+${CREATE_SHLIB-PROVIDE (__init_array_start = .);}}
+  .init_array   ${RELOCATING-0} : { KEEP (*(.init_array)) }
+  ${RELOCATING+${CREATE_SHLIB-PROVIDE (__init_array_end = .);}}
+
+  ${RELOCATING+${CREATE_SHLIB-PROVIDE (__fini_array_start = .);}}
+  .fini_array   ${RELOCATING-0} : { KEEP (*(.fini_array)) }
+  ${RELOCATING+${CREATE_SHLIB-PROVIDE (__fini_array_end = .);}}
+
+  ${SMALL_DATA_CTOR-${RELOCATING+${CTOR}}}
+  ${SMALL_DATA_DTOR-${RELOCATING+${DTOR}}}
+  .jcr          ${RELOCATING-0} : { KEEP (*(.jcr)) }
+
+  ${RELOCATING+${DATARELRO}}
+  ${OTHER_RELRO_SECTIONS}
+  ${TEXT_DYNAMIC-${DYNAMIC}}
+  ${NO_SMALL_DATA+${RELRO_NOW+${GOT}}}
+  ${NO_SMALL_DATA+${RELRO_NOW-${SEPARATE_GOTPLT+${GOT}}}}
+  ${NO_SMALL_DATA+${RELRO_NOW-${SEPARATE_GOTPLT+${GOTPLT}}}}
+  ${RELOCATING+${DATA_SEGMENT_RELRO_END}}
+  ${NO_SMALL_DATA+${RELRO_NOW-${SEPARATE_GOTPLT-${GOT}}}}
+
+  ${DATA_PLT+${PLT_BEFORE_GOT-${PLT}}}
+
+  .data         ${RELOCATING-0} :
+  {
+    ${RELOCATING+${DATA_START_SYMBOLS}}
+    *(.data${RELOCATING+ .data.* .gnu.linkonce.d.*})
+    KEEP (*(.gnu.linkonce.d.*personality*))
+    ${CONSTRUCTING+SORT(CONSTRUCTORS)}
+  }
+  .data1        ${RELOCATING-0} : { *(.data1) }
+  ${WRITABLE_RODATA+${RODATA}}
+  ${OTHER_READWRITE_SECTIONS}
+  ${SMALL_DATA_CTOR+${RELOCATING+${CTOR}}}
+  ${SMALL_DATA_DTOR+${RELOCATING+${DTOR}}}
+  ${DATA_PLT+${PLT_BEFORE_GOT+${PLT}}}
+  ${RELOCATING+${OTHER_GOT_SYMBOLS}}
+  ${NO_SMALL_DATA-${GOT}}
+  ${OTHER_GOT_SECTIONS}
+  ${SDATA}
+  ${OTHER_SDATA_SECTIONS}
+  ${RELOCATING+_edata = .;}
+  ${RELOCATING+PROVIDE (edata = .);}
+  ${RELOCATING+__bss_start = .;}
+  ${RELOCATING+${OTHER_BSS_SYMBOLS}}
+  ${SBSS}
+  ${BSS_PLT+${PLT}}
+  .bss          ${RELOCATING-0} :
+  {
+   *(.dynbss)
+   *(.bss${RELOCATING+ .bss.* .gnu.linkonce.b.*})
+   *(COMMON)
+   /* Align here to ensure that the .bss section occupies space up to
+      _end.  Align after .bss to ensure correct alignment even if the
+      .bss section disappears because there are no input sections.  */
+   ${RELOCATING+. = ALIGN(${ALIGNMENT});}
+  }
+  ${OTHER_BSS_SECTIONS}
+  ${RELOCATING+. = ALIGN(${ALIGNMENT});}
+  ${RELOCATING+_end = .;}
+  ${RELOCATING+${OTHER_BSS_END_SYMBOLS}}
+  ${RELOCATING+PROVIDE (end = .);}
+  ${RELOCATING+${DATA_SEGMENT_END}}
+
+  /* Stabs debugging sections.  */
+  .stab          0 : { *(.stab) }
+  .stabstr       0 : { *(.stabstr) }
+  .stab.excl     0 : { *(.stab.excl) }
+  .stab.exclstr  0 : { *(.stab.exclstr) }
+  .stab.index    0 : { *(.stab.index) }
+  .stab.indexstr 0 : { *(.stab.indexstr) }
+
+  .comment       0 : { *(.comment) }
+
+  /* DWARF debug sections.
+     Symbols in the DWARF debugging sections are relative to the beginning
+     of the section so we begin them at 0.  */
+
+  /* DWARF 1 */
+  .debug          0 : { *(.debug) }
+  .line           0 : { *(.line) }
+
+  /* GNU DWARF 1 extensions */
+  .debug_srcinfo  0 : { *(.debug_srcinfo) }
+  .debug_sfnames  0 : { *(.debug_sfnames) }
+
+  /* DWARF 1.1 and DWARF 2 */
+  .debug_aranges  0 : { *(.debug_aranges) }
+  .debug_pubnames 0 : { *(.debug_pubnames) }
+
+  /* DWARF 2 */
+  .debug_info     0 : { *(.debug_info .gnu.linkonce.wi.*) }
+  .debug_abbrev   0 : { *(.debug_abbrev) }
+  .debug_line     0 : { *(.debug_line) }
+  .debug_frame    0 : { *(.debug_frame) }
+  .debug_str      0 : { *(.debug_str) }
+  .debug_loc      0 : { *(.debug_loc) }
+  .debug_macinfo  0 : { *(.debug_macinfo) }
+
+  /* SGI/MIPS DWARF 2 extensions */
+  .debug_weaknames 0 : { *(.debug_weaknames) }
+  .debug_funcnames 0 : { *(.debug_funcnames) }
+  .debug_typenames 0 : { *(.debug_typenames) }
+  .debug_varnames  0 : { *(.debug_varnames) }
+
+  ${STACK_ADDR+${STACK}}
+  ${OTHER_SECTIONS}
+  ${RELOCATING+${OTHER_END_SYMBOLS}}
+  ${RELOCATING+${STACKNOTE}}
+}
+EOF
--- binutils-2.16.orig/opcodes/mips-dis.c	2005-03-03 03:49:50.000000000 -0800
+++ binutils-psp/opcodes/mips-dis.c	2005-08-22 09:10:31.102134376 -0700
@@ -140,6 +140,139 @@
   "c0_taglo",     "c0_taghi",     "c0_errorepc",  "c0_desave",
 };
 
+static const char * const vfpu_sreg_names[128] = {
+  "S000",  "S010",  "S020",  "S030",  "S100",  "S110",  "S120",  "S130",
+  "S200",  "S210",  "S220",  "S230",  "S300",  "S310",  "S320",  "S330",
+  "S400",  "S410",  "S420",  "S430",  "S500",  "S510",  "S520",  "S530",
+  "S600",  "S610",  "S620",  "S630",  "S700",  "S710",  "S720",  "S730",
+  "S001",  "S011",  "S021",  "S031",  "S101",  "S111",  "S121",  "S131",
+  "S201",  "S211",  "S221",  "S231",  "S301",  "S311",  "S321",  "S331",
+  "S401",  "S411",  "S421",  "S431",  "S501",  "S511",  "S521",  "S531",
+  "S601",  "S611",  "S621",  "S631",  "S701",  "S711",  "S721",  "S731",
+  "S002",  "S012",  "S022",  "S032",  "S102",  "S112",  "S122",  "S132",
+  "S202",  "S212",  "S222",  "S232",  "S302",  "S312",  "S322",  "S332",
+  "S402",  "S412",  "S422",  "S432",  "S502",  "S512",  "S522",  "S532",
+  "S602",  "S612",  "S622",  "S632",  "S702",  "S712",  "S722",  "S732",
+  "S003",  "S013",  "S023",  "S033",  "S103",  "S113",  "S123",  "S133",
+  "S203",  "S213",  "S223",  "S233",  "S303",  "S313",  "S323",  "S333",
+  "S403",  "S413",  "S423",  "S433",  "S503",  "S513",  "S523",  "S533",
+  "S603",  "S613",  "S623",  "S633",  "S703",  "S713",  "S723",  "S733"
+};
+
+static const char * const vfpu_vpreg_names[128] = {
+  "C000",  "C010",  "C020",  "C030",  "C100",  "C110",  "C120",  "C130",
+  "C200",  "C210",  "C220",  "C230",  "C300",  "C310",  "C320",  "C330",
+  "C400",  "C410",  "C420",  "C430",  "C500",  "C510",  "C520",  "C530",
+  "C600",  "C610",  "C620",  "C630",  "C700",  "C710",  "C720",  "C730",
+  "R000",  "R001",  "R002",  "R003",  "R100",  "R101",  "R102",  "R103",
+  "R200",  "R201",  "R202",  "R203",  "R300",  "R301",  "R302",  "R303",
+  "R400",  "R401",  "R402",  "R403",  "R500",  "R501",  "R502",  "R503",
+  "R600",  "R601",  "R602",  "R603",  "R700",  "R701",  "R702",  "R703",
+  "C002",  "C012",  "C022",  "C032",  "C102",  "C112",  "C122",  "C132",
+  "C202",  "C212",  "C222",  "C232",  "C302",  "C312",  "C322",  "C332",
+  "C402",  "C412",  "C422",  "C432",  "C502",  "C512",  "C522",  "C532",
+  "C602",  "C612",  "C622",  "C632",  "C702",  "C712",  "C722",  "C732",
+  "R020",  "R021",  "R022",  "R023",  "R120",  "R121",  "R122",  "R123",
+  "R220",  "R221",  "R222",  "R223",  "R320",  "R321",  "R322",  "R323",
+  "R420",  "R421",  "R422",  "R423",  "R520",  "R521",  "R522",  "R523",
+  "R620",  "R621",  "R622",  "R623",  "R720",  "R721",  "R722",  "R723"
+};
+
+static const char * const vfpu_vtreg_names[128] = {
+  "C000",  "C010",  "C020",  "C030",  "C100",  "C110",  "C120",  "C130",
+  "C200",  "C210",  "C220",  "C230",  "C300",  "C310",  "C320",  "C330",
+  "C400",  "C410",  "C420",  "C430",  "C500",  "C510",  "C520",  "C530",
+  "C600",  "C610",  "C620",  "C630",  "C700",  "C710",  "C720",  "C730",
+  "R000",  "R001",  "R002",  "R003",  "R100",  "R101",  "R102",  "R103",
+  "R200",  "R201",  "R202",  "R203",  "R300",  "R301",  "R302",  "R303",
+  "R400",  "R401",  "R402",  "R403",  "R500",  "R501",  "R502",  "R503",
+  "R600",  "R601",  "R602",  "R603",  "R700",  "R701",  "R702",  "R703",
+  "C001",  "C011",  "C021",  "C031",  "C101",  "C111",  "C121",  "C131",
+  "C201",  "C211",  "C221",  "C231",  "C301",  "C311",  "C321",  "C331",
+  "C401",  "C411",  "C421",  "C431",  "C501",  "C511",  "C521",  "C531",
+  "C601",  "C611",  "C621",  "C631",  "C701",  "C711",  "C721",  "C731",
+  "R010",  "R011",  "R012",  "R013",  "R110",  "R111",  "R112",  "R113",
+  "R210",  "R211",  "R212",  "R213",  "R310",  "R311",  "R312",  "R313",
+  "R410",  "R411",  "R412",  "R413",  "R510",  "R511",  "R512",  "R513",
+  "R610",  "R611",  "R612",  "R613",  "R710",  "R711",  "R712",  "R713"
+};
+
+static const char * const vfpu_vqreg_names[128] = {
+  "C000",  "C010",  "C020",  "C030",  "C100",  "C110",  "C120",  "C130",
+  "C200",  "C210",  "C220",  "C230",  "C300",  "C310",  "C320",  "C330",
+  "C400",  "C410",  "C420",  "C430",  "C500",  "C510",  "C520",  "C530",
+  "C600",  "C610",  "C620",  "C630",  "C700",  "C710",  "C720",  "C730",
+  "R000",  "R001",  "R002",  "R003",  "R100",  "R101",  "R102",  "R103",
+  "R200",  "R201",  "R202",  "R203",  "R300",  "R301",  "R302",  "R303",
+  "R400",  "R401",  "R402",  "R403",  "R500",  "R501",  "R502",  "R503",
+  "R600",  "R601",  "R602",  "R603",  "R700",  "R701",  "R702",  "R703",
+  "",  "",  "",  "",  "",  "",  "",  "",
+  "",  "",  "",  "",  "",  "",  "",  "",
+  "",  "",  "",  "",  "",  "",  "",  "",
+  "",  "",  "",  "",  "",  "",  "",  "",
+  "",  "",  "",  "",  "",  "",  "",  "",
+  "",  "",  "",  "",  "",  "",  "",  "",
+  "",  "",  "",  "",  "",  "",  "",  "",
+  "",  "",  "",  "",  "",  "",  "",  ""
+};
+
+static const char * const vfpu_mpreg_names[128] = {
+  "M000",  "",  "M020",  "",  "M100",  "",  "M120",  "",
+  "M200",  "",  "M220",  "",  "M300",  "",  "M320",  "",
+  "M400",  "",  "M420",  "",  "M500",  "",  "M520",  "",
+  "M600",  "",  "M620",  "",  "M700",  "",  "M720",  "",
+  "E000",  "",  "E002",  "",  "E100",  "",  "E102",  "",
+  "E200",  "",  "E202",  "",  "E300",  "",  "E302",  "",
+  "E400",  "",  "E402",  "",  "E500",  "",  "E502",  "",
+  "E600",  "",  "E602",  "",  "E700",  "",  "E702",  "",
+  "M002",  "",  "M022",  "",  "M102",  "",  "M122",  "",
+  "M202",  "",  "M222",  "",  "M302",  "",  "M322",  "",
+  "M402",  "",  "M422",  "",  "M502",  "",  "M522",  "",
+  "M602",  "",  "M622",  "",  "M702",  "",  "M722",  "",
+  "E020",  "",  "E022",  "",  "E120",  "",  "E122",  "",
+  "E220",  "",  "E222",  "",  "E320",  "",  "E322",  "",
+  "E420",  "",  "E422",  "",  "E520",  "",  "E522",  "",
+  "E620",  "",  "E622",  "",  "E720",  "",  "E722",  ""
+};
+
+static const char * const vfpu_mtreg_names[128] = {
+  "M000",  "M010",  "",  "",  "M100",  "M110",  "",  "",
+  "M200",  "M210",  "",  "",  "M300",  "M310",  "",  "",
+  "M400",  "M410",  "",  "",  "M500",  "M510",  "",  "",
+  "M600",  "M610",  "",  "",  "M700",  "M710",  "",  "",
+  "E000",  "E001",  "",  "",  "E100",  "E101",  "",  "",
+  "E200",  "E201",  "",  "",  "E300",  "E301",  "",  "",
+  "E400",  "E401",  "",  "",  "E500",  "E501",  "",  "",
+  "E600",  "E601",  "",  "",  "E700",  "E701",  "",  "",
+  "M001",  "M011",  "",  "",  "M101",  "M111",  "",  "",
+  "M201",  "M211",  "",  "",  "M301",  "M311",  "",  "",
+  "M401",  "M411",  "",  "",  "M501",  "M511",  "",  "",
+  "M601",  "M611",  "",  "",  "M701",  "M711",  "",  "",
+  "E010",  "E011",  "",  "",  "E110",  "E111",  "",  "",
+  "E210",  "E211",  "",  "",  "E310",  "E311",  "",  "",
+  "E410",  "E411",  "",  "",  "E510",  "E511",  "",  "",
+  "E610",  "E611",  "",  "",  "E710",  "E711",  "",  ""
+};
+
+static const char * const vfpu_mqreg_names[128] = {
+  "M000",  "",  "",  "",  "M100",  "",  "",  "",
+  "M200",  "",  "",  "",  "M300",  "",  "",  "",
+  "M400",  "",  "",  "",  "M500",  "",  "",  "",
+  "M600",  "",  "",  "",  "M700",  "",  "",  "",
+  "E000",  "",  "",  "",  "E100",  "",  "",  "",
+  "E200",  "",  "",  "",  "E300",  "",  "",  "",
+  "E400",  "",  "",  "",  "E500",  "",  "",  "",
+  "E600",  "",  "",  "",  "E700",  "",  "",  "",
+  "",  "",  "",  "",  "",  "",  "",  "",
+  "",  "",  "",  "",  "",  "",  "",  "",
+  "",  "",  "",  "",  "",  "",  "",  "",
+  "",  "",  "",  "",  "",  "",  "",  "",
+  "",  "",  "",  "",  "",  "",  "",  "",
+  "",  "",  "",  "",  "",  "",  "",  "",
+  "",  "",  "",  "",  "",  "",  "",  "",
+  "",  "",  "",  "",  "",  "",  "",  ""
+};
+
 static const struct mips_cp0sel_name mips_cp0sel_names_mips3264[] = {
   { 16, 1, "c0_config1"		},
   { 16, 2, "c0_config2"		},
@@ -288,6 +421,54 @@
   "$24",  "$25",  "$26",  "$27",  "$28",  "$29",  "$30",  "$31"
 };
 
+static const char * const vfpu_cond_names[16] = {
+  "FL",  "EQ",  "LT",  "LE",  "TR",  "NE",  "GE",  "GT",
+  "EZ",  "EN",  "EI",  "ES",  "NZ",  "NN",  "NI",  "NS"
+};
+
+static const char * const vfpu_const_names[20] = {
+  "",
+  "VFPU_HUGE",
+  "VFPU_SQRT2",
+  "VFPU_SQRT1_2",
+  "VFPU_2_SQRTPI",
+  "VFPU_2_PI",
+  "VFPU_1_PI",
+  "VFPU_PI_4",
+  "VFPU_PI_2",
+  "VFPU_PI",
+  "VFPU_E",
+  "VFPU_LOG2E",
+  "VFPU_LOG10E",
+  "VFPU_LN2",
+  "VFPU_LN10",
+  "VFPU_2PI",
+  "VFPU_PI_6",
+  "VFPU_LOG10TWO",
+  "VFPU_LOG2TEN",
+  "VFPU_SQRT3_2"
+};
+
+#define VFPU_NUM_CONSTANTS \
+  ((sizeof vfpu_const_names) / (sizeof (vfpu_const_names[0])))
+const unsigned int vfpu_num_constants = VFPU_NUM_CONSTANTS;
+
+static const char * const vfpu_rwb_names[4] = {
+  "wt",  "wb",  "",  ""
+};
+
+static const char * const pfx_cst_names[8] = {
+  "0",  "1",  "2",  "1/2",  "3",  "1/3",  "1/4",  "1/6"
+};
+
+static const char * const pfx_swz_names[4] = {
+  "x",  "y",  "z",  "w"
+};
+
+static const char * const pfx_sat_names[4] = {
+  "",  "[0:1]",  "",  "[-1:1]"
+};
+
 struct mips_abi_choice {
   const char *name;
   const char * const *gpr_names;
@@ -359,6 +540,8 @@
     mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
   { "mips5",	1, bfd_mach_mips5, CPU_MIPS5, ISA_MIPS5,
     mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
+  { "allegrex", 1, bfd_mach_mips_allegrex, CPU_ALLEGREX, ISA_MIPS2,
+    mips_cp0_names_numeric, NULL, 0, mips_hwr_names_numeric },
 
   /* For stock MIPS32, disassemble all applicable MIPS-specified ASEs.
      Note that MIPS-3D and MDMX are not applicable to MIPS32.  (See
@@ -1031,6 +1214,349 @@
 				 (l >> OP_SH_FT) & OP_MASK_FT);
 	  break;
 
+	case '?':
+	  /* VFPU extensions.  */
+	  d++;
+	  switch (*d)
+	    {
+	    case '\0':
+	      /* xgettext:c-format */
+	      (*info->fprintf_func) (info->stream,
+				     _("# internal error, incomplete VFPU extension sequence (?)"));
+	      return;
+
+	    case 'o':
+	      delta = (l >> OP_SH_VFPU_DELTA) & OP_MASK_VFPU_DELTA;
+	      if (delta & 0x8000)
+		delta |= ~0xffff;
+	      (*info->fprintf_func) (info->stream, "%d",
+				     delta);
+	      break;
+
+	    case '0':
+	    case '1':
+	    case '2':
+	    case '3':
+	      {
+		unsigned int pos = *d, base = '0';
+		unsigned int negation = (l >> (pos - (base - VFPU_SH_PFX_NEG))) & VFPU_MASK_PFX_NEG;
+		unsigned int constant = (l >> (pos - (base - VFPU_SH_PFX_CST))) & VFPU_MASK_PFX_CST;
+		unsigned int abs_consthi =
+		    (l >> (pos - (base - VFPU_SH_PFX_ABS_CSTHI))) & VFPU_MASK_PFX_ABS_CSTHI;
+		unsigned int swz_constlo = (l >> ((pos - base) * 2)) & VFPU_MASK_PFX_SWZ_CSTLO;
+
+		if (negation)
+		  (*info->fprintf_func) (info->stream, "-");
+		if (constant)
+		  {
+		    (*info->fprintf_func) (info->stream, "%s",
+                                           pfx_cst_names[(abs_consthi << 2) | swz_constlo]);
+		  }
+		else
+		  {
+		    if (abs_consthi)
+		      (*info->fprintf_func) (info->stream, "|%s|",
+					     pfx_swz_names[swz_constlo]);
+		    else
+		      (*info->fprintf_func) (info->stream, "%s",
+					     pfx_swz_names[swz_constlo]);
+		  }
+	      }
+	      break;
+
+	    case '4':
+	    case '5':
+	    case '6':
+	    case '7':
+	      {
+		unsigned int pos = *d, base = '4';
+		unsigned int mask = (l >> (pos - (base - VFPU_MASK_PFX_MASK))) & VFPU_MASK_PFX_MASK;
+		unsigned int saturation = (l >> ((pos - base) * 2)) & VFPU_MASK_PFX_SAT;
+
+		if (mask)
+		  (*info->fprintf_func) (info->stream, "m");
+		else
+		  (*info->fprintf_func) (info->stream, "%s",
+                                         pfx_sat_names[saturation]);
+	      }
+	      break;
+
+	    case 'a':
+	      {
+		unsigned int c = (l >> OP_SH_VFPU_CONST) & OP_MASK_VFPU_CONST;
+		if (c < vfpu_num_constants)
+		  {
+		    (*info->fprintf_func) (info->stream, "%s",
+					   vfpu_const_names[c]);
+		  }
+		break;
+	      }
+
+	    case 'b':
+	      /* 5-bit immediate value.  */
+	      (*info->fprintf_func) (info->stream, "%d",
+				     (l >> OP_SH_VFPU_IMM5) & OP_MASK_VFPU_IMM5);
+	      break;
+
+	    case 'c':
+	      /* VFPU condition code.  */
+	      (*info->fprintf_func) (info->stream, "%d",
+				     (l >> OP_SH_VFPU_CC) & OP_MASK_VFPU_CC);
+	      break;
+
+	    case 'e':
+	      /* 3-bit immediate value.  */
+	      (*info->fprintf_func) (info->stream, "%d",
+				     (l >> OP_SH_VFPU_IMM3) & OP_MASK_VFPU_IMM3);
+	      break;
+
+	    case 'f':
+	      /* Conditional compare.  */
+	      (*info->fprintf_func) (info->stream, "%s",
+				     vfpu_cond_names[(l >> OP_SH_VFPU_COND) & OP_MASK_VFPU_COND]);
+	      /* Apparently this specifier is unused.  */
+	      d++;
+	      break;
+
+	    case 'i':
+	      /* 8-bit immediate value.  */
+	      (*info->fprintf_func) (info->stream, "0x%02x",
+				     (l >> OP_SH_VFPU_IMM8) & OP_MASK_VFPU_IMM8);
+	      break;
+
+	    case 'q':
+	      /* VFPU control register (vmtvc).  */
+	      (*info->fprintf_func) (info->stream, "$%d",
+				     (l >> OP_SH_VFPU_VMTVC) & OP_MASK_VFPU_VMTVC);
+	      break;
+
+	    case 'r':
+	      /* VFPU control register (vmfvc).  */
+	      (*info->fprintf_func) (info->stream, "$%d",
+				     (l >> OP_SH_VFPU_VMFVC) & OP_MASK_VFPU_VMFVC);
+	      break;
+
+	    case 'u':
+	      /* Convert a VFPU 16-bit floating-point number to IEEE754. */
+	      {
+		union float2int {
+			unsigned int i;
+			float f;
+		} float2int;
+		unsigned short float16 = (l >> OP_SH_VFPU_FLOAT16) & OP_MASK_VFPU_FLOAT16;
+		unsigned int sign = (float16 >> VFPU_SH_FLOAT16_SIGN) & VFPU_MASK_FLOAT16_SIGN;
+		int exponent = (float16 >> VFPU_SH_FLOAT16_EXP) & VFPU_MASK_FLOAT16_EXP;
+		unsigned int fraction = float16 & VFPU_MASK_FLOAT16_FRAC;
+		char signchar = '+' + ((sign == 1) * 2);
+
+		if (exponent == VFPU_FLOAT16_EXP_MAX)
+		  {
+		    if (fraction == 0)
+		      (*info->fprintf_func) (info->stream, "%cInf", signchar);
+		    else
+		      (*info->fprintf_func) (info->stream, "%cNaN", signchar);
+		  }
+		else if (exponent == 0 && fraction == 0)
+		  {
+		    (*info->fprintf_func) (info->stream, "%c0", signchar);
+		  }
+		else
+		  {
+		    if (exponent == 0)
+		      {
+			do
+			  {
+			    fraction <<= 1;
+			    exponent--;
+			  }
+			while (!(fraction & (VFPU_MASK_FLOAT16_FRAC + 1)));
+
+			fraction &= VFPU_MASK_FLOAT16_FRAC;
+		      }
+
+		    /* Convert to 32-bit single-precision IEEE754. */
+		    float2int.i = sign << 31;
+		    float2int.i |= (exponent + 112) << 23;
+		    float2int.i |= fraction << 13;
+		    (*info->fprintf_func) (info->stream, "%g", float2int.f);
+		  }
+	      }
+	      break;
+
+	    case 'w':
+	      {
+		const char *elements[4];
+		unsigned int opcode = l & VFPU_MASK_OP_SIZE;
+		unsigned int rotators = (l >> OP_SH_VFPU_ROT) & OP_MASK_VFPU_ROT;
+		unsigned int opsize, rothi, rotlo, negation, i;
+
+		/* Determine the operand size so we'll know how many elements to output. */
+		if (opcode == VFPU_OP_SIZE_PAIR)
+		  opsize = 2;
+		else if (opcode == VFPU_OP_SIZE_TRIPLE)
+		  opsize = 3;
+		else
+		  opsize = (opcode == VFPU_OP_SIZE_QUAD) * 4;	/* Sanity check. */
+
+		rothi = (rotators >> VFPU_SH_ROT_HI) & VFPU_MASK_ROT_HI;
+		rotlo = (rotators >> VFPU_SH_ROT_LO) & VFPU_MASK_ROT_LO;
+		negation = (rotators >> VFPU_SH_ROT_NEG) & VFPU_MASK_ROT_NEG;
+
+		if (rothi == rotlo)
+		  {
+		    if (negation)
+		      {
+			elements[0] = "-s";
+			elements[1] = "-s";
+			elements[2] = "-s";
+			elements[3] = "-s";
+		      }
+		    else
+		      {
+			elements[0] = "s";
+			elements[1] = "s";
+			elements[2] = "s";
+			elements[3] = "s";
+		      }
+		  }
+		else
+		  {
+		    elements[0] = "0";
+		    elements[1] = "0";
+		    elements[2] = "0";
+		    elements[3] = "0";
+		  }
+		if (negation)
+		  elements[rothi] = "-s";
+		else
+		  elements[rothi] = "s";
+		elements[rotlo] = "c";
+
+		(*info->fprintf_func) (info->stream, "[");
+		i = 0;
+		for (;;)
+		  {
+		    (*info->fprintf_func) (info->stream, "%s",
+					   elements[i++]);
+		    if (i >= opsize)
+		      break;
+		    (*info->fprintf_func) (info->stream, ",");
+		  }
+		(*info->fprintf_func) (info->stream, "]");
+	      }
+	      break;
+
+	    case 'd':
+	    case 'm':
+	    case 'n':
+	    case 's':
+	    case 't':
+	    case 'v':
+	    case 'x':
+	      {
+		unsigned int vreg = 0;
+
+		/* The first char specifies the bitfield that contains the register number. */
+		switch (*d)
+		  {
+		  case 'd':
+		  case 'v':
+		  case 'x':
+		    vreg = (l >> OP_SH_VFPU_VD) & OP_MASK_VFPU_VD;
+		    break;
+
+		  case 'm':
+		    /* Combine bits 0-4 of vt with bits 5-6 of vt. */
+		    vreg = ((l >> OP_SH_VFPU_VT_LO) & OP_MASK_VFPU_VT_LO)
+			    | ((l & OP_MASK_VFPU_VT_HI2) << OP_SH_VFPU_VT_HI);
+		    break;
+
+		  case 'n':
+		    /* Combine bits 0-4 of vt with bit 5 of vt. */
+		    vreg = ((l >> OP_SH_VFPU_VT_LO) & OP_MASK_VFPU_VT_LO)
+			    | ((l & OP_MASK_VFPU_VT_HI1) << OP_SH_VFPU_VT_HI);
+		    break;
+
+		  case 's':
+		    {
+			unsigned int temp_vreg = l >> OP_SH_VFPU_VS;
+
+			vreg = temp_vreg & OP_MASK_VFPU_VS;
+			if ((l & VFPU_OP_VT_VS_VD) == VFPU_OPCODE_VMMUL)
+			  {
+			    /* vmmul instructions have the RXC bit (bit 13) inverted. */
+			    if (temp_vreg & 0x20)
+			      vreg = temp_vreg & 0x5f;
+			    else
+			      vreg |= 0x20;
+			  }
+		    }
+		    break;
+
+		  case 't':
+		    vreg = (l >> OP_SH_VFPU_VT) & OP_MASK_VFPU_VT;
+		    break;
+		  }
+
+		/* The next char is the register set vreg comes from. */
+		d++;
+		switch (*d)
+		  {
+		  case '0':
+		    (*info->fprintf_func) (info->stream, "%s.s",
+					   vfpu_sreg_names[vreg]);
+		    break;
+
+		  case '1':
+		    (*info->fprintf_func) (info->stream, "%s.p",
+					   vfpu_vpreg_names[vreg]);
+		    break;
+
+		  case '2':
+		    (*info->fprintf_func) (info->stream, "%s.t",
+					   vfpu_vtreg_names[vreg]);
+		    break;
+
+		  case '3':
+		    (*info->fprintf_func) (info->stream, "%s.q",
+					   vfpu_vqreg_names[vreg]);
+		    break;
+
+		  case '5':
+		    (*info->fprintf_func) (info->stream, "%s.p",
+					   vfpu_mpreg_names[vreg]);
+		    break;
+
+		  case '6':
+		    (*info->fprintf_func) (info->stream, "%s.t",
+					   vfpu_mtreg_names[vreg]);
+		    break;
+
+		  case '7':
+		    (*info->fprintf_func) (info->stream, "%s.q",
+					   vfpu_mqreg_names[vreg]);
+		    break;
+
+		  default:
+		    /* xgettext:c-format */
+		    (*info->fprintf_func) (info->stream,
+					   _("# internal error, undefined vreg modifier(%c)"),
+					   *d);
+		    break;
+		  }
+
+		/* The last char is unused for disassembly. */
+		d++;
+	      }
+	      break;
+
+	    case 'z':
+	      (*info->fprintf_func) (info->stream, "%s",
+				     vfpu_rwb_names[(l >> OP_SH_VFPU_RWB) & OP_MASK_VFPU_RWB]);
+	      break;
+	    }
+	  break;
+
 	default:
 	  /* xgettext:c-format */
 	  (*info->fprintf_func) (info->stream,
--- binutils-2.16.orig/opcodes/mips-opc.c	2005-03-03 03:49:50.000000000 -0800
+++ binutils-psp/opcodes/mips-opc.c	2005-08-22 09:01:05.972047208 -0700
@@ -109,6 +109,7 @@
 #define N5	(INSN_5400 | INSN_5500)
 #define N54	INSN_5400
 #define N55	INSN_5500
+#define AL	INSN_ALLEGREX
 
 #define G1      (T3             \
                  )
@@ -271,6 +272,7 @@
 {"bnel",    "s,t,p",	0x54000000, 0xfc000000,	CBL|RD_s|RD_t, 		0,		I2|T3	},
 {"bnel",    "s,I,p",	0,    (int) M_BNEL_I,	INSN_MACRO,		0,		I2|T3	},
 {"break",   "",		0x0000000d, 0xffffffff,	TRAP,			0,		I1	},
+{"break",   "B",	0x0000000d, 0xfc00003f,	TRAP,			0,		I32|AL	},
 {"break",   "c",	0x0000000d, 0xfc00ffff,	TRAP,			0,		I1	},
 {"break",   "c,q",	0x0000000d, 0xfc00003f,	TRAP,			0,		I1	},
 {"c.f.d",   "S,T",	0x46200030, 0xffe007ff,	RD_S|RD_T|WR_CC|FP_D,	0,		I1	},
@@ -432,7 +434,7 @@
 {"cabs.un.d",  "M,S,T",	0x46200071, 0xffe000ff,	RD_S|RD_T|WR_CC|FP_D,	0,		M3D	},
 {"cabs.un.ps", "M,S,T",	0x46c00071, 0xffe000ff,	RD_S|RD_T|WR_CC|FP_D,	0,		M3D	},
 {"cabs.un.s",  "M,S,T",	0x46000071, 0xffe000ff,	RD_S|RD_T|WR_CC|FP_S,	0,		M3D	},
-{"cache",   "k,o(b)",   0xbc000000, 0xfc000000, RD_b,           	0,		I3|I32|T3},
+{"cache",   "k,o(b)",   0xbc000000, 0xfc000000, RD_b,           	0,		I3|I32|T3|AL},
 {"ceil.l.d", "D,S",	0x4620000a, 0xffff003f, WR_D|RD_S|FP_D,		0,		I3	},
 {"ceil.l.s", "D,S",	0x4600000a, 0xffff003f, WR_D|RD_S|FP_S,		0,		I3	},
 {"ceil.w.d", "D,S",	0x4620000e, 0xffff003f, WR_D|RD_S|FP_D,		0,		I2	},
@@ -443,7 +445,9 @@
 /* cfc2 is at the bottom of the table.  */
 {"cfc3",    "t,G",	0x4c400000, 0xffe007ff,	LCD|WR_t|RD_C3,		0,		I1	},
 {"clo",     "U,s",      0x70000021, 0xfc0007ff, WR_d|WR_t|RD_s, 	0,		I32|N55 },
+{"clo",     "d,s",      0x00000017, 0xfc1f07ff, WR_d|RD_s,      	0,		AL	},
 {"clz",     "U,s",      0x70000020, 0xfc0007ff, WR_d|WR_t|RD_s, 	0,		I32|N55 },
+{"clz",     "d,s",      0x00000016, 0xfc1f07ff, WR_d|RD_s,              0,              AL      },
 {"ctc0",    "t,G",	0x40c00000, 0xffe007ff,	COD|RD_t|WR_CC,		0,		I1	},
 {"ctc1",    "t,G",	0x44c00000, 0xffe007ff,	COD|RD_t|WR_CC|FP_S,	0,		I1	},
 {"ctc1",    "t,S",	0x44c00000, 0xffe007ff,	COD|RD_t|WR_CC|FP_S,	0,		I1	},
@@ -465,10 +469,12 @@
 {"cvt.ps.s","D,V,T",	0x46000026, 0xffe0003f,	WR_D|RD_S|RD_T|FP_D,	0,		I5	},
 {"cvt.pw.ps", "D,S",	0x46c00024, 0xffff003f,	WR_D|RD_S|FP_S|FP_D,	0,		M3D	},
 {"dabs",    "d,v",	0,    (int) M_DABS,	INSN_MACRO,		0,		I3	},
+{"max",     "d,v,t",    0x0000002c, 0xfc0007ff, WR_d|RD_s|RD_t,         0,              AL	},
 {"dadd",    "d,v,t",	0x0000002c, 0xfc0007ff, WR_d|RD_s|RD_t,		0,		I3	},
 {"dadd",    "t,r,I",	0,    (int) M_DADD_I,	INSN_MACRO,		0,		I3	},
 {"daddi",   "t,r,j",	0x60000000, 0xfc000000, WR_t|RD_s,		0,		I3	},
 {"daddiu",  "t,r,j",	0x64000000, 0xfc000000, WR_t|RD_s,		0,		I3	},
+{"min",     "d,v,t",    0x0000002d, 0xfc0007ff, WR_d|RD_s|RD_t,         0,              AL	},
 {"daddu",   "d,v,t",	0x0000002d, 0xfc0007ff, WR_d|RD_s|RD_t,		0,		I3	},
 {"daddu",   "t,r,I",	0,    (int) M_DADDU_I,	INSN_MACRO,		0,		I3	},
 {"dbreak",  "",		0x7000003f, 0xffffffff,	0,			0,		N5	},
@@ -595,8 +601,8 @@
 {"dsubu",   "d,v,I",	0,    (int) M_DSUBU_I,	INSN_MACRO,		0,		I3	},
 {"ei",      "",		0x41606020, 0xffffffff,	WR_t|WR_C0,		0,		I33	},
 {"ei",      "t",	0x41606020, 0xffe0ffff,	WR_t|WR_C0,		0,		I33	},
-{"eret",    "",         0x42000018, 0xffffffff, 0,      		0,		I3|I32	},
-{"ext",     "t,r,+A,+C", 0x7c000000, 0xfc00003f, WR_t|RD_s,    		0,		I33	},
+{"eret",    "",         0x42000018, 0xffffffff, 0,      		0,		I3|I32|AL	},
+{"ext",     "t,r,+A,+C", 0x7c000000, 0xfc00003f, WR_t|RD_s,    		0,		I33|AL	},
 {"floor.l.d", "D,S",	0x4620000b, 0xffff003f, WR_D|RD_S|FP_D,		0,		I3	},
 {"floor.l.s", "D,S",	0x4600000b, 0xffff003f, WR_D|RD_S|FP_S,		0,		I3	},
 {"floor.w.d", "D,S",	0x4620000f, 0xffff003f, WR_D|RD_S|FP_D,		0,		I2	},
@@ -605,7 +611,7 @@
 {"flushd",  "",		0xbc020000, 0xffffffff, 0, 			0,		L1	},
 {"flushid", "",		0xbc030000, 0xffffffff, 0, 			0,		L1	},
 {"hibernate","",        0x42000023, 0xffffffff,	0, 			0,		V1	},
-{"ins",     "t,r,+A,+B", 0x7c000004, 0xfc00003f, WR_t|RD_s,    		0,		I33	},
+{"ins",     "t,r,+A,+B", 0x7c000004, 0xfc00003f, WR_t|RD_s,    		0,		I33|AL	},
 {"jr",      "s",	0x00000008, 0xfc1fffff,	UBD|RD_s,		0,		I1	},
 {"jr.hb",   "s",	0x00000408, 0xfc1fffff,	UBD|RD_s,		0,		I33	},
 {"j",       "s",	0x00000008, 0xfc1fffff,	UBD|RD_s,		0,		I1	}, /* jr */
@@ -639,18 +645,10 @@
 {"ld",	    "t,o(b)",   0xdc000000, 0xfc000000, WR_t|RD_b,		0,		I3	},
 {"ld",      "t,o(b)",	0,    (int) M_LD_OB,	INSN_MACRO,		0,		I1	},
 {"ld",      "t,A(b)",	0,    (int) M_LD_AB,	INSN_MACRO,		0,		I1	},
-{"ldc1",    "T,o(b)",	0xd4000000, 0xfc000000, CLD|RD_b|WR_T|FP_D,	0,		I2	},
-{"ldc1",    "E,o(b)",	0xd4000000, 0xfc000000, CLD|RD_b|WR_T|FP_D,	0,		I2	},
-{"ldc1",    "T,A(b)",	0,    (int) M_LDC1_AB,	INSN_MACRO,		0,		I2	},
-{"ldc1",    "E,A(b)",	0,    (int) M_LDC1_AB,	INSN_MACRO,		0,		I2	},
-{"l.d",     "T,o(b)",	0xd4000000, 0xfc000000, CLD|RD_b|WR_T|FP_D,	0,		I2	}, /* ldc1 */
-{"l.d",     "T,o(b)",	0,    (int) M_L_DOB,	INSN_MACRO,		0,		I1	},
-{"l.d",     "T,A(b)",	0,    (int) M_L_DAB,	INSN_MACRO,		0,		I1	},
-{"ldc2",    "E,o(b)",	0xd8000000, 0xfc000000, CLD|RD_b|WR_CC,		0,		I2	},
-{"ldc2",    "E,A(b)",	0,    (int) M_LDC2_AB,	INSN_MACRO,		0,		I2	},
-{"ldc3",    "E,o(b)",	0xdc000000, 0xfc000000, CLD|RD_b|WR_CC,		0,		I2	},
-{"ldc3",    "E,A(b)",	0,    (int) M_LDC3_AB,	INSN_MACRO,		0,		I2	},
-{"ldl",	    "t,o(b)",	0x68000000, 0xfc000000, LDD|WR_t|RD_b,		0,		I3	},
+/* ldc1 is at the bottom of the table.  */
+/* ldc2 is at the bottom of the table.  */
+/* ldc3 is at the bottom of the table.  */
+{"ldl",	    "t,o(b)",	0x68000000, 0xfc000000, LDD|WR_t|RD_b,		0,		I3|AL	},
 {"ldl",	    "t,A(b)",	0,    (int) M_LDL_AB,	INSN_MACRO,		0,		I3	},
 {"ldr",	    "t,o(b)",	0x6c000000, 0xfc000000, LDD|WR_t|RD_b,		0,		I3	},
 {"ldr",     "t,A(b)",	0,    (int) M_LDR_AB,	INSN_MACRO,		0,		I3	},
@@ -680,8 +678,7 @@
 {"lwc1",    "E,A(b)",	0,    (int) M_LWC1_AB,	INSN_MACRO,		0,		I1	},
 {"l.s",     "T,o(b)",	0xc4000000, 0xfc000000,	CLD|RD_b|WR_T|FP_S,	0,		I1	}, /* lwc1 */
 {"l.s",     "T,A(b)",	0,    (int) M_LWC1_AB,	INSN_MACRO,		0,		I1	},
-{"lwc2",    "E,o(b)",	0xc8000000, 0xfc000000,	CLD|RD_b|WR_CC,		0,		I1	},
-{"lwc2",    "E,A(b)",	0,    (int) M_LWC2_AB,	INSN_MACRO,		0,		I1	},
+/* lwc2 is at the bottom of the table.  */
 {"lwc3",    "E,o(b)",	0xcc000000, 0xfc000000,	CLD|RD_b|WR_CC,		0,		I1	},
 {"lwc3",    "E,A(b)",	0,    (int) M_LWC3_AB,	INSN_MACRO,		0,		I1	},
 {"lwl",     "t,o(b)",	0x88000000, 0xfc000000,	LDD|RD_b|WR_t,		0,		I1	},
@@ -713,10 +710,12 @@
 {"madd.s",  "D,R,S,T",	0x4c000020, 0xfc00003f, RD_R|RD_S|RD_T|WR_D|FP_S,    0,		I4	},
 {"madd.ps", "D,R,S,T",	0x4c000026, 0xfc00003f, RD_R|RD_S|RD_T|WR_D|FP_D,    0,		I5	},
 {"madd",    "s,t",      0x0000001c, 0xfc00ffff, RD_s|RD_t|WR_HILO,           0,		L1 },
+{"madd",    "s,t",      0x0000001c, 0xfc00ffff, RD_s|RD_t|WR_HILO|IS_M,      0,         AL	},
 {"madd",    "s,t",      0x70000000, 0xfc00ffff, RD_s|RD_t|MOD_HILO,          0,		I32|N55},
 {"madd",    "s,t",      0x70000000, 0xfc00ffff, RD_s|RD_t|WR_HILO|IS_M,      0,		G1 },
 {"madd",    "d,s,t",    0x70000000, 0xfc0007ff, RD_s|RD_t|WR_HILO|WR_d|IS_M, 0,		G1 },
 {"maddu",   "s,t",      0x0000001d, 0xfc00ffff, RD_s|RD_t|WR_HILO,           0,		L1 },
+{"maddu",   "s,t",      0x0000001d, 0xfc00ffff, RD_s|RD_t|WR_HILO|IS_M,      0,         AL	},
 {"maddu",   "s,t",      0x70000001, 0xfc00ffff, RD_s|RD_t|MOD_HILO,          0,		I32|N55},
 {"maddu",   "s,t",      0x70000001, 0xfc00ffff, RD_s|RD_t|WR_HILO|IS_M,      0,		G1	},
 {"maddu",   "d,s,t",    0x70000001, 0xfc0007ff, RD_s|RD_t|WR_HILO|WR_d|IS_M, 0,		G1	},
@@ -756,7 +755,7 @@
 {"movf.l",  "X,Y,N",	0x46a00011, 0xffe3003f, WR_D|RD_S|RD_CC|FP_D,	0,		MX|SB1	},
 {"movf.s",  "D,S,N",    0x46000011, 0xffe3003f, WR_D|RD_S|RD_CC|FP_S,   0,		I4|I32	},
 {"movf.ps", "D,S,N",	0x46c00011, 0xffe3003f, WR_D|RD_S|RD_CC|FP_D,	0,		I5	},
-{"movn",    "d,v,t",    0x0000000b, 0xfc0007ff, WR_d|RD_s|RD_t, 	0,		I4|I32	},
+{"movn",    "d,v,t",    0x0000000b, 0xfc0007ff, WR_d|RD_s|RD_t, 	0,		I4|I32|AL	},
 {"ffc",     "d,v",	0x0000000b, 0xfc1f07ff,	WR_d|RD_s,		0,		L1	},
 {"movn.d",  "D,S,t",    0x46200013, 0xffe0003f, WR_D|RD_S|RD_t|FP_D,    0,		I4|I32	},
 {"movn.l",  "D,S,t",    0x46a00013, 0xffe0003f, WR_D|RD_S|RD_t|FP_D,    0,		MX|SB1	},
@@ -769,7 +768,7 @@
 {"movt.l",  "X,Y,N",    0x46a10011, 0xffe3003f, WR_D|RD_S|RD_CC|FP_D,   0,		MX|SB1	},
 {"movt.s",  "D,S,N",    0x46010011, 0xffe3003f, WR_D|RD_S|RD_CC|FP_S,   0,		I4|I32	},
 {"movt.ps", "D,S,N",	0x46c10011, 0xffe3003f, WR_D|RD_S|RD_CC|FP_D,	0,		I5	},
-{"movz",    "d,v,t",    0x0000000a, 0xfc0007ff, WR_d|RD_s|RD_t, 	0,		I4|I32	},
+{"movz",    "d,v,t",    0x0000000a, 0xfc0007ff, WR_d|RD_s|RD_t, 	0,		I4|I32|AL	},
 {"ffs",     "d,v",	0x0000000a, 0xfc1f07ff,	WR_d|RD_s,		0,		L1	},
 {"movz.d",  "D,S,t",    0x46200012, 0xffe0003f, WR_D|RD_S|RD_t|FP_D,    0,		I4|I32	},
 {"movz.l",  "D,S,t",    0x46a00012, 0xffe0003f, WR_D|RD_S|RD_t|FP_D,    0,		MX|SB1	},
@@ -786,8 +785,10 @@
 {"msub.s",  "D,R,S,T",	0x4c000028, 0xfc00003f, RD_R|RD_S|RD_T|WR_D|FP_S, 0,		I4	},
 {"msub.ps", "D,R,S,T",	0x4c00002e, 0xfc00003f, RD_R|RD_S|RD_T|WR_D|FP_D, 0,		I5	},
 {"msub",    "s,t",      0x0000001e, 0xfc00ffff, RD_s|RD_t|WR_HILO,	0,		L1    	},
+{"msub",    "s,t",      0x0000002e, 0xfc00ffff, RD_s|RD_t|WR_HILO|IS_M, 0,              AL	},
 {"msub",    "s,t",      0x70000004, 0xfc00ffff, RD_s|RD_t|MOD_HILO,     0,		I32|N55 },
 {"msubu",   "s,t",      0x0000001f, 0xfc00ffff, RD_s|RD_t|WR_HILO,	0,		L1	},
+{"msubu",   "s,t",      0x0000002f, 0xfc00ffff, RD_s|RD_t|WR_HILO|IS_M, 0,              AL	},
 {"msubu",   "s,t",      0x70000005, 0xfc00ffff, RD_s|RD_t|MOD_HILO,     0,		I32|N55	},
 {"mtpc",    "t,P",	0x4080c801, 0xffe0ffc1,	COD|RD_t|WR_C0,		0,		M1|N5	},
 {"mtps",    "t,P",	0x4080c800, 0xffe0ffc1,	COD|RD_t|WR_C0,		0,		M1|N5	},
@@ -936,13 +937,13 @@
 {"rol",     "d,v,I",	0,    (int) M_ROL_I,	INSN_MACRO,		0,		I1	},
 {"ror",     "d,v,t",	0,    (int) M_ROR,	INSN_MACRO,		0,		I1	},
 {"ror",     "d,v,I",	0,    (int) M_ROR_I,	INSN_MACRO,		0,		I1	},
-{"ror",	    "d,w,<",	0x00200002, 0xffe0003f,	WR_d|RD_t,		0,		N5|I33	},
-{"rorv",    "d,t,s",	0x00000046, 0xfc0007ff,	RD_t|RD_s|WR_d,		0,		N5|I33	},
-{"rotl",    "d,v,t",	0,    (int) M_ROL,	INSN_MACRO,		0,		I33	},
-{"rotl",    "d,v,I",	0,    (int) M_ROL_I,	INSN_MACRO,		0,		I33	},
-{"rotr",    "d,v,t",	0,    (int) M_ROR,	INSN_MACRO,		0,		I33	},
-{"rotr",    "d,v,I",	0,    (int) M_ROR_I,	INSN_MACRO,		0,		I33	},
-{"rotrv",   "d,t,s",	0x00000046, 0xfc0007ff,	RD_t|RD_s|WR_d,		0,		I33	},
+{"ror",	    "d,w,<",	0x00200002, 0xffe0003f,	WR_d|RD_t,		0,		N5|I33|AL	},
+{"rorv",    "d,t,s",	0x00000046, 0xfc0007ff,	RD_t|RD_s|WR_d,		0,		N5|I33|AL	},
+{"rotl",    "d,v,t",	0,    (int) M_ROL,	INSN_MACRO,		0,		I33|AL	},
+{"rotl",    "d,v,I",	0,    (int) M_ROL_I,	INSN_MACRO,		0,		I33|AL	},
+{"rotr",    "d,v,t",	0,    (int) M_ROR,	INSN_MACRO,		0,		I33|AL	},
+{"rotr",    "d,v,I",	0,    (int) M_ROR_I,	INSN_MACRO,		0,		I33|AL	},
+{"rotrv",   "d,t,s",	0x00000046, 0xfc0007ff,	RD_t|RD_s|WR_d,		0,		I33|AL	},
 {"round.l.d", "D,S",	0x46200008, 0xffff003f, WR_D|RD_S|FP_D,		0,		I3	},
 {"round.l.s", "D,S",	0x46000008, 0xffff003f, WR_D|RD_S|FP_S,		0,		I3	},
 {"round.w.d", "D,S",	0x4620000c, 0xffff003f, WR_D|RD_S|FP_D,		0,		I2	},
@@ -974,24 +975,17 @@
 {"sdbbp",   "c,q",	0x0000000e, 0xfc00003f,	TRAP,			0,		G2	},
 {"sdbbp",   "",         0x7000003f, 0xffffffff, TRAP,           	0,		I32     },
 {"sdbbp",   "B",        0x7000003f, 0xfc00003f, TRAP,           	0,		I32     },
-{"sdc1",    "T,o(b)",	0xf4000000, 0xfc000000, SM|RD_T|RD_b|FP_D,	0,		I2	},
-{"sdc1",    "E,o(b)",	0xf4000000, 0xfc000000, SM|RD_T|RD_b|FP_D,	0,		I2	},
-{"sdc1",    "T,A(b)",	0,    (int) M_SDC1_AB,	INSN_MACRO,		0,		I2	},
-{"sdc1",    "E,A(b)",	0,    (int) M_SDC1_AB,	INSN_MACRO,		0,		I2	},
-{"sdc2",    "E,o(b)",	0xf8000000, 0xfc000000, SM|RD_C2|RD_b,		0,		I2	},
-{"sdc2",    "E,A(b)",	0,    (int) M_SDC2_AB,	INSN_MACRO,		0,		I2	},
-{"sdc3",    "E,o(b)",	0xfc000000, 0xfc000000, SM|RD_C3|RD_b,		0,		I2	},
-{"sdc3",    "E,A(b)",	0,    (int) M_SDC3_AB,	INSN_MACRO,		0,		I2	},
-{"s.d",     "T,o(b)",	0xf4000000, 0xfc000000, SM|RD_T|RD_b|FP_D,	0,		I2	},
-{"s.d",     "T,o(b)",	0,    (int) M_S_DOB,	INSN_MACRO,		0,		I1	},
-{"s.d",     "T,A(b)",	0,    (int) M_S_DAB,	INSN_MACRO,		0,		I1	},
-{"sdl",     "t,o(b)",	0xb0000000, 0xfc000000,	SM|RD_t|RD_b,		0,		I3	},
+/* sdc1 is at the bottom of the table.  */
+/* sdc2 is at the bottom of the table.  */
+/* sdc3 is at the bottom of the table.  */
+/* s.d (sdc1 is at the bottom of the table.  */
+{"sdl",     "t,o(b)",	0xb0000000, 0xfc000000,	SM|RD_t|RD_b,		0,		I3|AL	},
 {"sdl",     "t,A(b)",	0,    (int) M_SDL_AB,	INSN_MACRO,		0,		I3	},
 {"sdr",     "t,o(b)",	0xb4000000, 0xfc000000,	SM|RD_t|RD_b,		0,		I3	},
 {"sdr",     "t,A(b)",	0,    (int) M_SDR_AB,	INSN_MACRO,		0,		I3	},
 {"sdxc1",   "S,t(b)",   0x4c000009, 0xfc0007ff, SM|RD_S|RD_t|RD_b,	0,		I4	},
-{"seb",     "d,w",	0x7c000420, 0xffe007ff,	WR_d|RD_t,		0,		I33	},
-{"seh",     "d,w",	0x7c000620, 0xffe007ff,	WR_d|RD_t,		0,		I33	},
+{"seb",     "d,w",	0x7c000420, 0xffe007ff,	WR_d|RD_t,		0,		I33|AL	},
+{"seh",     "d,w",	0x7c000620, 0xffe007ff,	WR_d|RD_t,		0,		I33|AL	},
 {"selsl",   "d,v,t",	0x00000005, 0xfc0007ff,	WR_d|RD_s|RD_t,		0,		L1	},
 {"selsr",   "d,v,t",	0x00000001, 0xfc0007ff,	WR_d|RD_s|RD_t,		0,		L1	},
 {"seq",     "d,v,t",	0,    (int) M_SEQ,	INSN_MACRO,		0,		I1	},
@@ -1083,8 +1077,7 @@
 {"swc1",    "E,A(b)",	0,    (int) M_SWC1_AB,	INSN_MACRO,		0,		I1	},
 {"s.s",     "T,o(b)",	0xe4000000, 0xfc000000,	SM|RD_T|RD_b|FP_S,	0,		I1	}, /* swc1 */
 {"s.s",     "T,A(b)",	0,    (int) M_SWC1_AB,	INSN_MACRO,		0,		I1	},
-{"swc2",    "E,o(b)",	0xe8000000, 0xfc000000,	SM|RD_C2|RD_b,		0,		I1	},
-{"swc2",    "E,A(b)",	0,    (int) M_SWC2_AB,	INSN_MACRO,		0,		I1	},
+/* swc2 is at the bottom of the table.  */
 {"swc3",    "E,o(b)",	0xec000000, 0xfc000000,	SM|RD_C3|RD_b,		0,		I1	},
 {"swc3",    "E,A(b)",	0,    (int) M_SWC3_AB,	INSN_MACRO,		0,		I1	},
 {"swl",     "t,o(b)",	0xa8000000, 0xfc000000,	SM|RD_t|RD_b,		0,		I1	},
@@ -1169,7 +1162,8 @@
 {"waiti",   "",		0x42000020, 0xffffffff,	TRAP,			0,		L1	},
 {"wb", 	    "o(b)",	0xbc040000, 0xfc1f0000, SM|RD_b,		0,		L1	},
 {"wrpgpr",  "d,w",	0x41c00000, 0xffe007ff, RD_t,			0,		I33	},
-{"wsbh",    "d,w",	0x7c0000a0, 0xffe007ff,	WR_d|RD_t,		0,		I33	},
+{"wsbh",    "d,w",	0x7c0000a0, 0xffe007ff,	WR_d|RD_t,		0,		I33|AL	},
+{"wsbw",    "d,t",	0x7c0000e0, 0xffe007ff, WR_d|RD_t,		0,		AL	},
 {"xor",     "d,v,t",	0x00000026, 0xfc0007ff,	WR_d|RD_s|RD_t,		0,		I1	},
 {"xor",     "t,r,I",	0,    (int) M_XOR_I,	INSN_MACRO,		0,		I1	},
 {"xor.ob",  "X,Y,Q",	0x7800000d, 0xfc20003f,	WR_D|RD_S|RD_T|FP_D,	0,		MX|SB1	},
@@ -1179,6 +1173,317 @@
 {"xor.qh",  "X,Y,Q",	0x7820000d, 0xfc20003f,	WR_D|RD_S|RD_T|FP_D,	0,		MX	},
 {"xori",    "t,r,i",	0x38000000, 0xfc000000,	WR_t|RD_s,		0,		I1	},
 
+/* Sony Allegrex CPU core.  */
+{"bitrev",  "d,t",      0x7c000520, 0xffe007ff, WR_d|RD_t,              0,              AL	},
+
+/* Sony Allegrex VFPU instructions.  */
+{"bvf",     "?c,p",		0x49000000, 0xffe30000, CBD|RD_CC,	0,		AL	},
+{"bvfl",    "?c,p",		0x49020000, 0xffe30000, CBL|RD_CC,	0,		AL	},
+{"bvt",     "?c,p",		0x49010000, 0xffe30000, CBD|RD_CC,	0,		AL	},
+{"bvtl",    "?c,p",		0x49030000, 0xffe30000, CBL|RD_CC,	0,		AL	},
+{"lv.s",    "?m0x,?o(b)",	0xc8000000, 0xfc000000, CLD|RD_s|WR_CC,	0,		AL	},
+{"lv.s",    "?m0x,A(b)",	0,    (int) M_LVQ_AB,	INSN_MACRO,	0,		AL	},
+{"ulv.s",   "?m0x,o(b)",	0,    (int) M_ULVS,	INSN_MACRO,	0,		AL	},
+{"lv.q",    "?n3x,?o(b)",	0xd8000000, 0xfc000002, CLD|RD_s|WR_CC,	0,		AL	},
+{"lv.q",    "?n3x,A(b)",	0,    (int) M_LVQ_AB_2,	INSN_MACRO,	0,		AL	},
+{"ulv.q",   "?n3x,?o(b)",	0,    (int) M_ULVQ,	INSN_MACRO,	0,		AL	},
+{"ulv.q",   "?n3x,A(b)",	0,    (int) M_ULVQ_AB,	INSN_MACRO,	0,		AL	},
+{"lvi.s",   "?t0x,l?y0",	0,    (int) M_LVIS,	INSN_MACRO,	0,		AL	},
+{"lvi.p",   "?t1x,?[l?y0,l?y1?]", 0,  (int) M_LVIP,	INSN_MACRO,	0,		AL	},
+{"lvi.t",   "?t2x,?[l?y0,l?y1,l?y2?]", 0, (int) M_LVIT,	INSN_MACRO,	0,		AL	},
+{"lvi.q",   "?t3x,?[l?y0,l?y1,l?y2,l?y3?]", 0, (int) M_LVIQ,	INSN_MACRO,	0,	AL	},
+{"lvhi.s",  "?t0x,?[?u?y0,?u?y1?]", 0, (int) M_LVHIS,	INSN_MACRO,	0,		AL	},
+{"lvhi.p",  "?t1x,?[?u?y0,?u?y1,?u?y2,?u?y3?]", 0, (int) M_LVHIP,	INSN_MACRO, 0,	AL	},
+{"sv.s",    "?m0x,?o(b)",	0xe8000000, 0xfc000000, SM|RD_s|RD_C2,	0,		AL	},
+{"sv.s",    "?m0x,A(b)",	0,    (int) M_SVS_AB,	INSN_MACRO,	0,		AL	},
+{"usv.s",   "?m0x,o(b)",	0,    (int) M_USVS,	INSN_MACRO,	0,		AL	},
+{"sv.q",    "?n3x,?o(b)",	0xf8000000, 0xfc000002, SM|RD_s|RD_C2,	0,		AL	},
+{"sv.q",    "?n3x,?o(b),?z",	0xf8000000, 0xfc000000, SM|RD_s|RD_C2,	0,		AL	},
+{"sv.q",    "?n3x,A(b)",	0,    (int) M_SVQ_AB,	INSN_MACRO,	0,		AL	},
+{"sv.q",    "?n3x,A(b),?z",	0,    (int) M_SVQ_AB,	INSN_MACRO,	0,		AL	},
+{"sv.q",    "?n3x,A,?z",	0,    (int) M_SVQ_AB,	INSN_MACRO,	0,		AL	},
+{"usv.q",   "?n3x,?o(b)",	0,    (int) M_USVQ,	INSN_MACRO,	0,		AL	},
+{"usv.q",   "?n3x,A(b)",	0,    (int) M_USVQ_AB,	INSN_MACRO,	0,		AL	},
+{"vwb.q",   "?n3x,?o(b)",	0xf8000002, 0xfc000002, SM|RD_s|RD_C2,	0,		AL	},
+{"lvl.q",   "?n3x,?o(b)",	0xd4000000, 0xfc000002, CLD|RD_s|WR_CC,	0,		AL	},
+{"lvl.q",   "?n3x,A(b)",	0,    (int) M_LVLQ_AB,	INSN_MACRO,	0,		AL	},
+{"lvr.q",   "?n3x,?o(b)",	0xd4000002, 0xfc000002, CLD|RD_s|WR_CC,	0,		AL	},
+{"lvr.q",   "?n3x,A(b)",	0,    (int) M_LVRQ_AB,	INSN_MACRO,	0,		AL	},
+{"svl.q",   "?n3x,?o(b)",	0xf4000000, 0xfc000002, SM|RD_s|RD_C2,	0,		AL	},
+{"svl.q",   "?n3x,A(b)",	0,    (int) M_SVLQ_AB,	INSN_MACRO,	0,		AL	},
+{"svr.q",   "?n3x,?o(b)",	0xf4000002, 0xfc000002, SM|RD_s|RD_C2,	0,		AL	},
+{"svr.q",   "?n3x,A(b)",	0,    (int) M_SVRQ_AB,	INSN_MACRO,	0,		AL	},
+{"mtv",     "t,?d0z",		0x48e00000, 0xffe0ff80, LCD|WR_t|WR_C2,	0,		AL	},
+{"mfv",     "t,?d0z",		0x48600000, 0xffe0ff80, COD|RD_t|WR_CC|RD_C2, 0,	AL	},
+{"mtvc",    "t,?q",		0x48e00000, 0xffe0ff00, LCD|WR_t|WR_C2,	0,		AL	},
+{"mfvc",    "t,?q",		0x48600000, 0xffe0ff00, COD|RD_t|WR_CC|RD_C2, 0,	AL	},
+{"vmtvc",   "?q,?s0y",		0xd0510000, 0xffff8000, WR_C2,		0,		AL	},
+{"vmfvc",   "?d0z,?r",		0xd0500000, 0xffff0080, RD_C2,		0,		AL	},
+{"vadd.q",  "?d3d,?s3s,?t3t",	0x60008080, 0xff808080, RD_C2,		0,		AL	},
+{"vsub.q",  "?d3d,?s3s,?t3t",	0x60808080, 0xff808080, RD_C2,		0,		AL	},
+{"vdiv.q",  "?x3z,?s3y,?t3x",	0x63808080, 0xff808080, RD_C2,		0,		AL	},
+{"vmul.q",  "?d3d,?s3s,?t3t",	0x64008080, 0xff808080, RD_C2,		0,		AL	},
+{"vdot.q",  "?d0d,?s3s,?t3t",	0x64808080, 0xff808080, RD_C2,		0,		AL	},
+{"vscl.q",  "?d3d,?s3s,?t0x",	0x65008080, 0xff808080, RD_C2,		0,		AL	},
+{"vhdp.q",  "?d0d,?s3y,?t3t",	0x66008080, 0xff808080, RD_C2,		0,		AL	},
+{"vcmp.q",  "?f2,?s3s,?t3t",	0x6c008080, 0xff8080f0, RD_C2,		0,		AL	},
+{"vcmp.q",  "?f1,?s3s",		0x6c008080, 0xffff80f0, RD_C2,		0,		AL	},
+{"vcmp.q",  "?f0",		0x6c008080, 0xfffffff0, RD_C2,		0,		AL	},
+{"vmin.q",  "?d3d,?s3s,?t3t",	0x6d008080, 0xff808080, RD_C2,		0,		AL	},
+{"vmax.q",  "?d3d,?s3s,?t3t",	0x6d808080, 0xff808080, RD_C2,		0,		AL	},
+{"vsgn.q",  "?d3d,?s3s",	0xd04a8080, 0xffff8080, RD_C2,		0,		AL	},
+{"vcst.q",  "?d3d,?a",		0xd0608080, 0xffe0ff80, RD_C2,		0,		AL	},
+{"vscmp.q", "?d3d,?s3s,?t3t",	0x6e808080, 0xff808080, RD_C2,		0,		AL	},
+{"vsge.q",  "?d3d,?s3s,?t3t",	0x6f008080, 0xff808080, RD_C2,		0,		AL	},
+{"vslt.q",  "?d3d,?s3s,?t3t",	0x6f808080, 0xff808080, RD_C2,		0,		AL	},
+{"vi2uc.q", "?d0m,?s3w",	0xd03c8080, 0xffff8080, RD_C2,		0,		AL	},
+{"vi2c.q",  "?d0m,?s3w",	0xd03d8080, 0xffff8080, RD_C2,		0,		AL	},
+{"vi2us.q", "?d1m,?s3w",	0xd03e8080, 0xffff8080, RD_C2,		0,		AL	},
+{"vi2s.q",  "?d1m,?s3w",	0xd03f8080, 0xffff8080, RD_C2,		0,		AL	},
+{"vmov.q",  "?d3d,?s3s",	0xd0008080, 0xffff8080, RD_C2,		0,		AL	},
+{"vabs.q",  "?d3d,?s3w",	0xd0018080, 0xffff8080, RD_C2,		0,		AL	},
+{"vneg.q",  "?d3d,?s3w",	0xd0028080, 0xffff8080, RD_C2,		0,		AL	},
+{"vidt.q",  "?d3d",		0xd0038080, 0xffffff80, RD_C2,		0,		AL	},
+{"vsat0.q", "?d3z,?s3s",	0xd0048080, 0xffff8080, RD_C2,		0,		AL	},
+{"vsat1.q", "?d3z,?s3s",	0xd0058080, 0xffff8080, RD_C2,		0,		AL	},
+{"vzero.q", "?d3d",		0xd0068080, 0xffffff80, RD_C2,		0,		AL	},
+{"vone.q",  "?d3d",		0xd0078080, 0xffffff80, RD_C2,		0,		AL	},
+{"vrcp.q",  "?x3z,?s3y",	0xd0108080, 0xffff8080, RD_C2,		0,		AL	},
+{"vrsq.q",  "?x3z,?s3y",	0xd0118080, 0xffff8080, RD_C2,		0,		AL	},
+{"vsin.q",  "?x3z,?s3y",	0xd0128080, 0xffff8080, RD_C2,		0,		AL	},
+{"vcos.q",  "?x3z,?s3y",	0xd0138080, 0xffff8080, RD_C2,		0,		AL	},
+{"vexp2.q", "?x3z,?s3y",	0xd0148080, 0xffff8080, RD_C2,		0,		AL	},
+{"vlog2.q", "?x3z,?s3y",	0xd0158080, 0xffff8080, RD_C2,		0,		AL	},
+{"vsqrt.q", "?x3z,?s3y",	0xd0168080, 0xffff8080, RD_C2,		0,		AL	},
+{"vasin.q", "?x3z,?s3y",	0xd0178080, 0xffff8080, RD_C2,		0,		AL	},
+{"vnrcp.q", "?x3z,?s3y",	0xd0188080, 0xffff8080, RD_C2,		0,		AL	},
+{"vnsin.q", "?x3z,?s3y",	0xd01a8080, 0xffff8080, RD_C2,		0,		AL	},
+{"vrexp2.q", "?x3z,?s3y",	0xd01c8080, 0xffff8080, RD_C2,		0,		AL	},
+{"vrndi.q", "?d3z",		0xd0218080, 0xffffff80, RD_C2,		0,		AL	},
+{"vrndf1.q", "?d3z",		0xd0228080, 0xffffff80, RD_C2,		0,		AL	},
+{"vrndf2.q", "?d3z",		0xd0238080, 0xffffff80, RD_C2,		0,		AL	},
+{"vf2h.q",  "?d1m,?s3s",	0xd0328080, 0xffff8080, RD_C2,		0,		AL	},
+{"vsrt1.q", "?d3d,?s3s",	0xd0408080, 0xffff8080, RD_C2,		0,		AL	},
+{"vsrt2.q", "?d3d,?s3s",	0xd0418080, 0xffff8080, RD_C2,		0,		AL	},
+{"vsrt3.q", "?d3d,?s3s",	0xd0488080, 0xffff8080, RD_C2,		0,		AL	},
+{"vsrt4.q", "?d3d,?s3s",	0xd0498080, 0xffff8080, RD_C2,		0,		AL	},
+{"vbfy1.q", "?d3d,?s3s",	0xd0428080, 0xffff8080, RD_C2,		0,		AL	},
+{"vbfy2.q", "?d3d,?s3s",	0xd0438080, 0xffff8080, RD_C2,		0,		AL	},
+{"vocp.q",  "?d3d,?s3y",	0xd0448080, 0xffff8080, RD_C2,		0,		AL	},
+{"vfad.q",  "?d0d,?s3s",	0xd0468080, 0xffff8080, RD_C2,		0,		AL	},
+{"vavg.q",  "?d0d,?s3s",	0xd0478080, 0xffff8080, RD_C2,		0,		AL	},
+{"vf2in.q", "?d3m,?s3s,?b",	0xd2008080, 0xffe08080, RD_C2,		0,		AL	},
+{"vf2iz.q", "?d3m,?s3s,?b",	0xd2208080, 0xffe08080, RD_C2,		0,		AL	},
+{"vf2iu.q", "?d3m,?s3s,?b",	0xd2408080, 0xffe08080, RD_C2,		0,		AL	},
+{"vf2id.q", "?d3m,?s3s,?b",	0xd2608080, 0xffe08080, RD_C2,		0,		AL	},
+{"vi2f.q",  "?d3d,?s3w,?b",	0xd2808080, 0xffe08080, RD_C2,		0,		AL	},
+{"vcmov.q", "?d3d,?s3s,?e",	0,    (int) M_VCMOVQ,	INSN_MACRO,	0,		AL	},
+{"vcmovt.q", "?d3d,?s3s,?e",	0xd2a08080, 0xfff88080, RD_C2,		0,		AL	},
+{"vcmovf.q", "?d3d,?s3s,?e",	0xd2a88080, 0xfff88080, RD_C2,		0,		AL	},
+{"vmmul.q", "?v7z,?s7y,?t7x",	0xf0008080, 0xff808080, RD_C2,		0,		AL	},
+{"vtfm4.q", "?v3z,?s7y,?t3x",	0xf1808080, 0xff808080, RD_C2,		0,		AL	},
+{"vhtfm4.q", "?v3z,?s7y,?t3x",	0xf1808000, 0xff808080, RD_C2,		0,		AL	},
+{"vmscl.q", "?x7z,?s7y,?t0x",	0xf2008080, 0xff808080, RD_C2,		0,		AL	},
+{"vqmul.q", "?v3z,?s3y,?t3x",	0xf2808080, 0xff808080, RD_C2,		0,		AL	},
+{"vmmov.q", "?x7z,?s7y",	0xf3808080, 0xffff8080, RD_C2,		0,		AL	},
+{"vmidt.q", "?d7z",		0xf3838080, 0xffffff80, RD_C2,		0,		AL	},
+{"vmzero.q", "?d7z",		0xf3868080, 0xffffff80, RD_C2,		0,		AL	},
+{"vmone.q", "?d7z",		0xf3878080, 0xffffff80, RD_C2,		0,		AL	},
+{"vrot.q",  "?x3z,?s0y,?w",	0xf3a08080, 0xffe08080, RD_C2,		0,		AL	},
+{"vt4444.q", "?d1z,?s3w",	0xd0598080, 0xffff8080, RD_C2,		0,		AL	},
+{"vt5551.q", "?d1z,?s3w",	0xd05a8080, 0xffff8080, RD_C2,		0,		AL	},
+{"vt5650.q", "?d1z,?s3w",	0xd05b8080, 0xffff8080, RD_C2,		0,		AL	},
+{"vadd.t",  "?d2d,?s2s,?t2t",	0x60008000, 0xff808080, RD_C2,		0,		AL	},
+{"vsub.t",  "?d2d,?s2s,?t2t",	0x60808000, 0xff808080, RD_C2,		0,		AL	},
+{"vdiv.t",  "?x2z,?s2y,?t2x",	0x63808000, 0xff808080, RD_C2,		0,		AL	},
+{"vmul.t",  "?d2d,?s2s,?t2t",	0x64008000, 0xff808080, RD_C2,		0,		AL	},
+{"vdot.t",  "?d0d,?s2s,?t2t",	0x64808000, 0xff808080, RD_C2,		0,		AL	},
+{"vscl.t",  "?d2d,?s2s,?t0x",	0x65008000, 0xff808080, RD_C2,		0,		AL	},
+{"vhdp.t",  "?d0d,?s2y,?t2t",	0x66008000, 0xff808080, RD_C2,		0,		AL	},
+{"vcrs.t",  "?d2d,?s2y,?t2x",	0x66808000, 0xff808080, RD_C2,		0,		AL	},
+{"vcmp.t",  "?f2,?s2s,?t2t",	0x6c008000, 0xff8080f0, RD_C2,		0,		AL	},
+{"vcmp.t",  "?f1,?s2s",		0x6c008000, 0xffff80f0, RD_C2,		0,		AL	},
+{"vcmp.t",  "?f0",		0x6c008000, 0xfffffff0, RD_C2,		0,		AL	},
+{"vmin.t",  "?d2d,?s2s,?t2t",	0x6d008000, 0xff808080, RD_C2,		0,		AL	},
+{"vmax.t",  "?d2d,?s2s,?t2t",	0x6d808000, 0xff808080, RD_C2,		0,		AL	},
+{"vsgn.t",  "?d2d,?s2s",	0xd04a8000, 0xffff8080, RD_C2,		0,		AL	},
+{"vcst.t",  "?d2d,?a",		0xd0608000, 0xffe0ff80, RD_C2,		0,		AL	},
+{"vscmp.t", "?d2d,?s2s,?t2t",	0x6e808000, 0xff808080, RD_C2,		0,		AL	},
+{"vsge.t",  "?d2d,?s2s,?t2t",	0x6f008000, 0xff808080, RD_C2,		0,		AL	},
+{"vslt.t",  "?d2d,?s2s,?t2t",	0x6f808000, 0xff808080, RD_C2,		0,		AL	},
+{"vmov.t",  "?d2d,?s2s",	0xd0008000, 0xffff8080, RD_C2,		0,		AL	},
+{"vabs.t",  "?d2d,?s2w",	0xd0018000, 0xffff8080, RD_C2,		0,		AL	},
+{"vneg.t",  "?d2d,?s2w",	0xd0028000, 0xffff8080, RD_C2,		0,		AL	},
+{"vsat0.t", "?d2z,?s2s",	0xd0048000, 0xffff8080, RD_C2,		0,		AL	},
+{"vsat1.t", "?d2z,?s2s",	0xd0058000, 0xffff8080, RD_C2,		0,		AL	},
+{"vzero.t", "?d2d",		0xd0068000, 0xffffff80, RD_C2,		0,		AL	},
+{"vone.t",  "?d2d",		0xd0078000, 0xffffff80, RD_C2,		0,		AL	},
+{"vrcp.t",  "?x2z,?s2y",	0xd0108000, 0xffff8080, RD_C2,		0,		AL	},
+{"vrsq.t",  "?x2z,?s2y",	0xd0118000, 0xffff8080, RD_C2,		0,		AL	},
+{"vsin.t",  "?x2z,?s2y",	0xd0128000, 0xffff8080, RD_C2,		0,		AL	},
+{"vcos.t",  "?x2z,?s2y",	0xd0138000, 0xffff8080, RD_C2,		0,		AL	},
+{"vexp2.t", "?x2z,?s2y",	0xd0148000, 0xffff8080, RD_C2,		0,		AL	},
+{"vlog2.t", "?x2z,?s2y",	0xd0158000, 0xffff8080, RD_C2,		0,		AL	},
+{"vsqrt.t", "?x2z,?s2y",	0xd0168000, 0xffff8080, RD_C2,		0,		AL	},
+{"vasin.t", "?x2z,?s2y",	0xd0178000, 0xffff8080, RD_C2,		0,		AL	},
+{"vnrcp.t", "?x2z,?s2y",	0xd0188000, 0xffff8080, RD_C2,		0,		AL	},
+{"vnsin.t", "?x2z,?s2y",	0xd01a8000, 0xffff8080, RD_C2,		0,		AL	},
+{"vrexp2.t", "?x2z,?s2y",	0xd01c8000, 0xffff8080, RD_C2,		0,		AL	},
+{"vrndi.t", "?d2z",		0xd0218000, 0xffffff80, RD_C2,		0,		AL	},
+{"vrndf1.t", "?d2z",		0xd0228000, 0xffffff80, RD_C2,		0,		AL	},
+{"vrndf2.t", "?d2z",		0xd0238000, 0xffffff80, RD_C2,		0,		AL	},
+{"vocp.t",  "?d2d,?s2y",	0xd0448000, 0xffff8080, RD_C2,		0,		AL	},
+{"vfad.t",  "?d0d,?s2s",	0xd0468000, 0xffff8080, RD_C2,		0,		AL	},
+{"vavg.t",  "?d0d,?s2s",	0xd0478000, 0xffff8080, RD_C2,		0,		AL	},
+{"vf2in.t", "?d2m,?s2s,?b",	0xd2008000, 0xffe08080, RD_C2,		0,		AL	},
+{"vf2iz.t", "?d2m,?s2s,?b",	0xd2208000, 0xffe08080, RD_C2,		0,		AL	},
+{"vf2iu.t", "?d2m,?s2s,?b",	0xd2408000, 0xffe08080, RD_C2,		0,		AL	},
+{"vf2id.t", "?d2m,?s2s,?b",	0xd2608000, 0xffe08080, RD_C2,		0,		AL	},
+{"vi2f.t",  "?d2d,?s2w,?b",	0xd2808000, 0xffe08080, RD_C2,		0,		AL	},
+{"vcmov.t", "?d2d,?s2s,?e",	0,    (int) M_VCMOVT,	INSN_MACRO,	0,		AL	},
+{"vcmovt.t", "?d2d,?s2s,?e",	0xd2a08000, 0xfff88080, RD_C2,		0,		AL	},
+{"vcmovf.t", "?d2d,?s2s,?e",	0xd2a88000, 0xfff88080, RD_C2,		0,		AL	},
+{"vmmul.t", "?v6z,?s6y,?t6x",	0xf0008000, 0xff808080, RD_C2,		0,		AL	},
+{"vtfm3.t", "?v2z,?s6y,?t2x",	0xf1008000, 0xff808080, RD_C2,		0,		AL	},
+{"vhtfm3.t", "?v2z,?s6y,?t2x",	0xf1000080, 0xff808080, RD_C2,		0,		AL	},
+{"vmscl.t", "?x6z,?s6y,?t0x",	0xf2008000, 0xff808080, RD_C2,		0,		AL	},
+{"vmmov.t", "?x6z,?s6y",	0xf3808000, 0xffff8080, RD_C2,		0,		AL	},
+{"vmidt.t", "?d6z",		0xf3838000, 0xffffff80, RD_C2,		0,		AL	},
+{"vmzero.t", "?d6z",		0xf3868000, 0xffffff80, RD_C2,		0,		AL	},
+{"vmone.t", "?d6z",		0xf3878000, 0xffffff80, RD_C2,		0,		AL	},
+{"vrot.t",  "?x2z,?s0y,?w",	0xf3a08000, 0xffe08080, RD_C2,		0,		AL	},
+{"vcrsp.t", "?d2z,?s2y,?t2x",	0xf2808000, 0xff808080, RD_C2,		0,		AL	},
+{"vadd.p",  "?d1d,?s1s,?t1t",	0x60000080, 0xff808080, RD_C2,		0,		AL	},
+{"vsub.p",  "?d1d,?s1s,?t1t",	0x60800080, 0xff808080, RD_C2,		0,		AL	},
+{"vdiv.p",  "?x1z,?s1y,?t1x",	0x63800080, 0xff808080, RD_C2,		0,		AL	},
+{"vmul.p",  "?d1d,?s1s,?t1t",	0x64000080, 0xff808080, RD_C2,		0,		AL	},
+{"vdot.p",  "?d0d,?s1s,?t1t",	0x64800080, 0xff808080, RD_C2,		0,		AL	},
+{"vscl.p",  "?d1d,?s1s,?t0x",	0x65000080, 0xff808080, RD_C2,		0,		AL	},
+{"vhdp.p",  "?d0d,?s1y,?t1t",	0x66000080, 0xff808080, RD_C2,		0,		AL	},
+{"vdet.p",  "?d0d,?s1s,?t1x",	0x67000080, 0xff808080, RD_C2,		0,		AL	},
+{"vcmp.p",  "?f2,?s1s,?t1t",	0x6c000080, 0xff8080f0, RD_C2,		0,		AL	},
+{"vcmp.p",  "?f1,?s1s",		0x6c000080, 0xffff80f0, RD_C2,		0,		AL	},
+{"vcmp.p",  "?f0",		0x6c000080, 0xfffffff0, RD_C2,		0,		AL	},
+{"vmin.p",  "?d1d,?s1s,?t1t",	0x6d000080, 0xff808080, RD_C2,		0,		AL	},
+{"vmax.p",  "?d1d,?s1s,?t1t",	0x6d800080, 0xff808080, RD_C2,		0,		AL	},
+{"vsgn.p",  "?d1d,?s1s",	0xd04a0080, 0xffff8080, RD_C2,		0,		AL	},
+{"vcst.p",  "?d1d,?a",		0xd0600080, 0xffe0ff80, RD_C2,		0,		AL	},
+{"vscmp.p", "?d1d,?s1s,?t1t",	0x6e800080, 0xff808080, RD_C2,		0,		AL	},
+{"vsge.p",  "?d1d,?s1s,?t1t",	0x6f000080, 0xff808080, RD_C2,		0,		AL	},
+{"vslt.p",  "?d1d,?s1s,?t1t",	0x6f800080, 0xff808080, RD_C2,		0,		AL	},
+{"vus2i.p", "?d3m,?s1y",	0xd03a0080, 0xffff8080, RD_C2,		0,		AL	},
+{"vs2i.p",  "?d3m,?s1y",	0xd03b0080, 0xffff8080, RD_C2,		0,		AL	},
+{"vi2us.p", "?d0m,?s1w",	0xd03e0080, 0xffff8080, RD_C2,		0,		AL	},
+{"vi2s.p",  "?d0m,?s1w",	0xd03f0080, 0xffff8080, RD_C2,		0,		AL	},
+{"vmov.p",  "?d1d,?s1s",	0xd0000080, 0xffff8080, RD_C2,		0,		AL	},
+{"vabs.p",  "?d1d,?s1w",	0xd0010080, 0xffff8080, RD_C2,		0,		AL	},
+{"vneg.p",  "?d1d,?s1w",	0xd0020080, 0xffff8080, RD_C2,		0,		AL	},
+{"vidt.p",  "?d1d",		0xd0030080, 0xffffff80, RD_C2,		0,		AL	},
+{"vsat0.p", "?d1z,?s1s",	0xd0040080, 0xffff8080, RD_C2,		0,		AL	},
+{"vsat1.p", "?d1z,?s1s",	0xd0050080, 0xffff8080, RD_C2,		0,		AL	},
+{"vzero.p", "?d1d",		0xd0060080, 0xffffff80, RD_C2,		0,		AL	},
+{"vone.p",  "?d1d",		0xd0070080, 0xffffff80, RD_C2,		0,		AL	},
+{"vrcp.p",  "?x1z,?s1y",	0xd0100080, 0xffff8080, RD_C2,		0,		AL	},
+{"vrsq.p",  "?x1z,?s1y",	0xd0110080, 0xffff8080, RD_C2,		0,		AL	},
+{"vsin.p",  "?x1z,?s1y",	0xd0120080, 0xffff8080, RD_C2,		0,		AL	},
+{"vcos.p",  "?x1z,?s1y",	0xd0130080, 0xffff8080, RD_C2,		0,		AL	},
+{"vexp2.p", "?x1z,?s1y",	0xd0140080, 0xffff8080, RD_C2,		0,		AL	},
+{"vlog2.p", "?x1z,?s1y",	0xd0150080, 0xffff8080, RD_C2,		0,		AL	},
+{"vsqrt.p", "?x1z,?s1y",	0xd0160080, 0xffff8080, RD_C2,		0,		AL	},
+{"vasin.p", "?x1z,?s1y",	0xd0170080, 0xffff8080, RD_C2,		0,		AL	},
+{"vnrcp.p", "?x1z,?s1y",	0xd0180080, 0xffff8080, RD_C2,		0,		AL	},
+{"vnsin.p", "?x1z,?s1y",	0xd01a0080, 0xffff8080, RD_C2,		0,		AL	},
+{"vrexp2.p", "?x1z,?s1y",	0xd01c0080, 0xffff8080, RD_C2,		0,		AL	},
+{"vrndi.p", "?d1z",		0xd0210080, 0xffffff80, RD_C2,		0,		AL	},
+{"vrndf1.p", "?d1z",		0xd0220080, 0xffffff80, RD_C2,		0,		AL	},
+{"vrndf2.p", "?d1z",		0xd0230080, 0xffffff80, RD_C2,		0,		AL	},
+{"vf2h.p",  "?d0m,?s1s",	0xd0320080, 0xffff8080, RD_C2,		0,		AL	},
+{"vh2f.p",  "?d3d,?s1y",	0xd0330080, 0xffff8080, RD_C2,		0,		AL	},
+{"vbfy1.p", "?d1d,?s1s",	0xd0420080, 0xffff8080, RD_C2,		0,		AL	},
+{"vocp.p",  "?d1d,?s1y",	0xd0440080, 0xffff8080, RD_C2,		0,		AL	},
+{"vsocp.p", "?d3z,?s1y",	0xd0450080, 0xffff8080, RD_C2,		0,		AL	},
+{"vfad.p",  "?d0d,?s1s",	0xd0460080, 0xffff8080, RD_C2,		0,		AL	},
+{"vavg.p",  "?d0d,?s1s",	0xd0470080, 0xffff8080, RD_C2,		0,		AL	},
+{"vf2in.p", "?d1m,?s1s,?b",	0xd2000080, 0xffe08080, RD_C2,		0,		AL	},
+{"vf2iz.p", "?d1m,?s1s,?b",	0xd2200080, 0xffe08080, RD_C2,		0,		AL	},
+{"vf2iu.p", "?d1m,?s1s,?b",	0xd2400080, 0xffe08080, RD_C2,		0,		AL	},
+{"vf2id.p", "?d1m,?s1s,?b",	0xd2600080, 0xffe08080, RD_C2,		0,		AL	},
+{"vi2f.p",  "?d1d,?s1w,?b",	0xd2800080, 0xffe08080, RD_C2,		0,		AL	},
+{"vcmov.p", "?d1d,?s1s,?e",	0,    (int) M_VCMOVP,	INSN_MACRO,	0,		AL	},
+{"vcmovt.p", "?d1d,?s1s,?e",	0xd2a00080, 0xfff88080, RD_C2,		0,		AL	},
+{"vcmovf.p", "?d1d,?s1s,?e",	0xd2a80080, 0xfff88080, RD_C2,		0,		AL	},
+{"vmmul.p", "?v5z,?s5y,?t5x",	0xf0000080, 0xff808080, RD_C2,		0,		AL	},
+{"vtfm2.p", "?v1z,?s5y,?t1x",	0xf0800080, 0xff808080, RD_C2,		0,		AL	},
+{"vhtfm2.p", "?v1z,?s5y,?t1x",	0xf0800000, 0xff808080, RD_C2,		0,		AL	},
+{"vmscl.p", "?x5z,?s5y,?t0x",	0xf2000080, 0xff808080, RD_C2,		0,		AL	},
+{"vmmov.p", "?x5z,?s5y",	0xf3800080, 0xffff8080, RD_C2,		0,		AL	},
+{"vmidt.p", "?d5z",		0xf3830080, 0xffffff80, RD_C2,		0,		AL	},
+{"vmzero.p", "?d5z",		0xf3860080, 0xffffff80, RD_C2,		0,		AL	},
+{"vmone.p", "?d5z",		0xf3870080, 0xffffff80, RD_C2,		0,		AL	},
+{"vrot.p",  "?x1z,?s0y,?w",	0xf3a00080, 0xffe08080, RD_C2,		0,		AL	},
+{"vadd.s",  "?d0d,?s0s,?t0t",	0x60000000, 0xff808080, RD_C2,		0,		AL	},
+{"vsub.s",  "?d0d,?s0s,?t0t",	0x60800000, 0xff808080, RD_C2,		0,		AL	},
+{"vdiv.s",  "?x0d,?s0s,?t0t",	0x63800000, 0xff808080, RD_C2,		0,		AL	},
+{"vmul.s",  "?d0d,?s0s,?t0t",	0x64000000, 0xff808080, RD_C2,		0,		AL	},
+{"vcmp.s",  "?f2,?s0s,?t0t",	0x6c000000, 0xff8080f0, RD_C2,		0,		AL	},
+{"vcmp.s",  "?f1,?s0s",		0x6c000000, 0xffff80f0, RD_C2,		0,		AL	},
+{"vcmp.s",  "?f0",		0x6c000000, 0xfffffff0, RD_C2,		0,		AL	},
+{"vmin.s",  "?d0d,?s0s,?t0t",	0x6d000000, 0xff808080, RD_C2,		0,		AL	},
+{"vmax.s",  "?d0d,?s0s,?t0t",	0x6d800000, 0xff808080, RD_C2,		0,		AL	},
+{"vsgn.s",  "?d0d,?s0s",	0xd04a0000, 0xffff8080, RD_C2,		0,		AL	},
+{"vcst.s",  "?d0d,?a",		0xd0600000, 0xffe0ff80, RD_C2,		0,		AL	},
+{"vscmp.s", "?d0d,?s0s,?t0t",	0x6e800000, 0xff808080, RD_C2,		0,		AL	},
+{"vsge.s",  "?d0d,?s0s,?t0t",	0x6f000000, 0xff808080, RD_C2,		0,		AL	},
+{"vslt.s",  "?d0d,?s0s,?t0t",	0x6f800000, 0xff808080, RD_C2,		0,		AL	},
+{"vus2i.s", "?d1m,?s0y",	0xd03a0000, 0xffff8080, RD_C2,		0,		AL	},
+{"vs2i.s",  "?d1m,?s0y",	0xd03b0000, 0xffff8080, RD_C2,		0,		AL	},
+{"vmov.s",  "?d0d,?s0s",	0xd0000000, 0xffff8080, RD_C2,		0,		AL	},
+{"vabs.s",  "?d0d,?s0w",	0xd0010000, 0xffff8080, RD_C2,		0,		AL	},
+{"vneg.s",  "?d0d,?s0w",	0xd0020000, 0xffff8080, RD_C2,		0,		AL	},
+{"vsat0.s", "?d0z,?s0s",	0xd0040000, 0xffff8080, RD_C2,		0,		AL	},
+{"vsat1.s", "?d0z,?s0s",	0xd0050000, 0xffff8080, RD_C2,		0,		AL	},
+{"vzero.s", "?d0d",		0xd0060000, 0xffffff80, RD_C2,		0,		AL	},
+{"vone.s",  "?d0d",		0xd0070000, 0xffffff80, RD_C2,		0,		AL	},
+{"vrcp.s",  "?x0d,?s0s",	0xd0100000, 0xffff8080, RD_C2,		0,		AL	},
+{"vrsq.s",  "?x0d,?s0s",	0xd0110000, 0xffff8080, RD_C2,		0,		AL	},
+{"vsin.s",  "?x0d,?s0s",	0xd0120000, 0xffff8080, RD_C2,		0,		AL	},
+{"vcos.s",  "?x0d,?s0s",	0xd0130000, 0xffff8080, RD_C2,		0,		AL	},
+{"vexp2.s", "?x0d,?s0s",	0xd0140000, 0xffff8080, RD_C2,		0,		AL	},
+{"vlog2.s", "?x0d,?s0s",	0xd0150000, 0xffff8080, RD_C2,		0,		AL	},
+{"vsqrt.s", "?x0d,?s0s",	0xd0160000, 0xffff8080, RD_C2,		0,		AL	},
+{"vasin.s", "?x0d,?s0s",	0xd0170000, 0xffff8080, RD_C2,		0,		AL	},
+{"vnrcp.s", "?x0d,?s0y",	0xd0180000, 0xffff8080, RD_C2,		0,		AL	},
+{"vnsin.s", "?x0d,?s0y",	0xd01a0000, 0xffff8080, RD_C2,		0,		AL	},
+{"vrexp2.s", "?x0d,?s0y",	0xd01c0000, 0xffff8080, RD_C2,		0,		AL	},
+{"vrnds.s", "?s0y",		0xd0200000, 0xffff80ff, RD_C2,		0,		AL	},
+{"vrndi.s", "?d0d",		0xd0210000, 0xffffff80, RD_C2,		0,		AL	},
+{"vrndf1.s", "?d0d",		0xd0220000, 0xffffff80, RD_C2,		0,		AL	},
+{"vrndf2.s", "?d0d",		0xd0230000, 0xffffff80, RD_C2,		0,		AL	},
+{"vh2f.s",  "?d1d,?s0y",	0xd0330000, 0xffff8080, RD_C2,		0,		AL	},
+{"vsbz.s",  "?d0d,?s0s",	0xd0360000, 0xffff8080, RD_C2,		0,		AL	},
+{"vsbn.s",  "?d0d,?s0s,?t0t",	0x61000000, 0xff808080, RD_C2,		0,		AL	},
+{"vlgb.s",  "?d0d,?s0s",	0xd0370000, 0xffff8080, RD_C2,		0,		AL	},
+{"vocp.s",  "?d0d,?s0y",	0xd0440000, 0xffff8080, RD_C2,		0,		AL	},
+{"vsocp.s", "?d1z,?s0y",	0xd0450000, 0xffff8080, RD_C2,		0,		AL	},
+{"vf2in.s", "?d0m,?s0s,?b",	0xd2000000, 0xffe08080, RD_C2,		0,		AL	},
+{"vf2iz.s", "?d0m,?s0s,?b",	0xd2200000, 0xffe08080, RD_C2,		0,		AL	},
+{"vf2iu.s", "?d0m,?s0s,?b",	0xd2400000, 0xffe08080, RD_C2,		0,		AL	},
+{"vf2id.s", "?d0m,?s0s,?b",	0xd2600000, 0xffe08080, RD_C2,		0,		AL	},
+{"vi2f.s",  "?d0d,?s0w,?b",	0xd2800000, 0xffe08080, RD_C2,		0,		AL	},
+{"vcmov.s", "?d0d,?s0s,?e",	0,    (int) M_VCMOVS,	INSN_MACRO,	0,		AL	},
+{"vcmovt.s", "?d0d,?s0s,?e",	0xd2a00000, 0xfff88080, RD_C2,		0,		AL	},
+{"vcmovf.s", "?d0d,?s0s,?e",	0xd2a80000, 0xfff88080, RD_C2,		0,		AL	},
+{"vwbn.s",  "?d0d,?s0s,?i",	0xd3000000, 0xff008080, RD_C2,		0,		AL	},
+{"vpfxs",   "?0,?1,?2,?3",	0xdc000000, 0xff000000, RD_C2,		0,		AL	},
+{"vpfxt",   "?0,?1,?2,?3",	0xdd000000, 0xff000000, RD_C2,		0,		AL	},
+{"vpfxd",   "?4,?5,?6,?7",	0xde000000, 0xff000000, RD_C2,		0,		AL	},
+{"viim.s",  "?t0d,j",		0xdf000000, 0xff800000, RD_C2,		0,		AL	},
+{"vfim.s",  "?t0d,?u",		0xdf800000, 0xff800000, RD_C2,		0,		AL	},
+{"vnop",    "",			0xffff0000, 0xffffffff, RD_C2,		0,		AL	},
+{"vflush",  "",			0xffff040d, 0xffffffff, RD_C2,		0,		AL	},
+{"vsync",   "",			0xffff0320, 0xffffffff, RD_C2,		0,		AL	},
+{"vsync",   "i",		0xffff0000, 0xffff0000, RD_C2,		0,		AL	},
+
 /* Coprocessor 2 move/branch operations overlap with VR5400 .ob format
    instructions so they are here for the latters to take precedence.  */
 {"bc2f",    "p",	0x49000000, 0xffff0000,	CBD|RD_CC,		0,		I1	},
@@ -1198,6 +1503,36 @@
 {"mtc2",    "t,G,H",	0x48800000, 0xffe007f8,	COD|RD_t|WR_C2|WR_CC,	0,		I32	},
 {"mthc2",   "t,i",	0x48e00000, 0xffe00000,	COD|RD_t|WR_C2|WR_CC,	0,		I33	},
 
+/* Coprocessor 2 load/store operations overlap with the Allegrex VFPU
+   instructions so they are here for the latters to take precedence.  */
+/* COP1 ldc1 and sdc1 and COP3 ldc3 and sdc3 also overlap with the VFPU.  */
+{"ldc1",    "T,o(b)",	0xd4000000, 0xfc000000, CLD|RD_b|WR_T|FP_D,	0,		I2	},
+{"ldc1",    "E,o(b)",	0xd4000000, 0xfc000000, CLD|RD_b|WR_T|FP_D,	0,		I2	},
+{"ldc1",    "T,A(b)",	0,    (int) M_LDC1_AB,	INSN_MACRO,		0,		I2	},
+{"ldc1",    "E,A(b)",	0,    (int) M_LDC1_AB,	INSN_MACRO,		0,		I2	},
+{"l.d",     "T,o(b)",	0xd4000000, 0xfc000000, CLD|RD_b|WR_T|FP_D,	0,		I2	}, /* ldc1 */
+{"l.d",     "T,o(b)",	0,    (int) M_L_DOB,	INSN_MACRO,		0,		I1	},
+{"l.d",     "T,A(b)",	0,    (int) M_L_DAB,	INSN_MACRO,		0,		I1	},
+{"ldc2",    "E,o(b)",	0xd8000000, 0xfc000000, CLD|RD_b|WR_CC,		0,		I2	},
+{"ldc2",    "E,A(b)",	0,    (int) M_LDC2_AB,	INSN_MACRO,		0,		I2	},
+{"ldc3",    "E,o(b)",	0xdc000000, 0xfc000000, CLD|RD_b|WR_CC,		0,		I2	},
+{"ldc3",    "E,A(b)",	0,    (int) M_LDC3_AB,	INSN_MACRO,		0,		I2	},
+{"lwc2",    "E,o(b)",	0xc8000000, 0xfc000000,	CLD|RD_b|WR_CC,		0,		I1	},
+{"lwc2",    "E,A(b)",	0,    (int) M_LWC2_AB,	INSN_MACRO,		0,		I1	},
+{"sdc1",    "T,o(b)",	0xf4000000, 0xfc000000, SM|RD_T|RD_b|FP_D,	0,		I2	},
+{"sdc1",    "E,o(b)",	0xf4000000, 0xfc000000, SM|RD_T|RD_b|FP_D,	0,		I2	},
+{"sdc1",    "T,A(b)",	0,    (int) M_SDC1_AB,	INSN_MACRO,		0,		I2	},
+{"sdc1",    "E,A(b)",	0,    (int) M_SDC1_AB,	INSN_MACRO,		0,		I2	},
+{"s.d",     "T,o(b)",	0xf4000000, 0xfc000000, SM|RD_T|RD_b|FP_D,	0,		I2	},
+{"s.d",     "T,o(b)",	0,    (int) M_S_DOB,	INSN_MACRO,		0,		I1	},
+{"s.d",     "T,A(b)",	0,    (int) M_S_DAB,	INSN_MACRO,		0,		I1	},
+{"sdc2",    "E,o(b)",	0xf8000000, 0xfc000000, SM|RD_C2|RD_b,		0,		I2	},
+{"sdc2",    "E,A(b)",	0,    (int) M_SDC2_AB,	INSN_MACRO,		0,		I2	},
+{"sdc3",    "E,o(b)",	0xfc000000, 0xfc000000, SM|RD_C3|RD_b,		0,		I2	},
+{"sdc3",    "E,A(b)",	0,    (int) M_SDC3_AB,	INSN_MACRO,		0,		I2	},
+{"swc2",    "E,o(b)",	0xe8000000, 0xfc000000,	SM|RD_C2|RD_b,		0,		I1	},
+{"swc2",    "E,A(b)",	0,    (int) M_SWC2_AB,	INSN_MACRO,		0,		I1	},
+
 /* No hazard protection on coprocessor instructions--they shouldn't
    change the state of the processor and if they do it's up to the
    user to put in nops as necessary.  These are at the end so that the
